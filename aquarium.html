<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BC2 Mempool Aquarium ‚Äî Live Transaction Fish Tank</title>
    <meta name="description" content="Watch BC2 transactions swim as bioluminescent creatures in a deep-sea aquarium. Real mempool data, visualized.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=DM+Serif+Display&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --gold: #F7931A;
            --gold-lt: #FFB347;
            --gold-deep: #B8860B;
            --abyss: #020810;
            --deep: #040E1A;
            --mid: #0A1628;
            --surface: #0F1F35;
            --glass: rgba(15,31,53,0.6);
            --t1: #E8EDF5;
            --t2: #7B8FA8;
            --t3: #3D5068;
            --fee-low: #F7931A;
            --fee-med: #F97316;
            --fee-high: #EF4444;
            --fee-urgent: #DC2626;
            --biolum: #4AEABC;
            --biolum2: #38BDF8;
        }

        html { height: 100%; }

        body {
            font-family: 'DM Sans', sans-serif;
            background: var(--abyss);
            color: var(--t1);
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* ‚ïê‚ïê‚ïê‚ïê Deep sea gradient background ‚ïê‚ïê‚ïê‚ïê */
        .ocean-bg {
            position: fixed; inset: 0; z-index: 0; pointer-events: none;
            background:
                radial-gradient(ellipse 80% 50% at 50% 0%, rgba(15,31,53,0.8), transparent),
                radial-gradient(ellipse 60% 60% at 20% 80%, rgba(56,189,248,0.03), transparent),
                radial-gradient(ellipse 50% 50% at 80% 60%, rgba(74,234,188,0.02), transparent),
                linear-gradient(180deg, #030C18 0%, #020810 30%, #010408 100%);
        }

        /* Caustic light rays from surface */
        .caustics {
            position: fixed; top: 0; left: 0; width: 100%; height: 35vh;
            pointer-events: none; z-index: 1; opacity: 0.25;
            background:
                conic-gradient(from 200deg at 30% 0%, transparent 42%, rgba(56,189,248,0.03) 44%, transparent 46%),
                conic-gradient(from 160deg at 55% 0%, transparent 43%, rgba(74,234,188,0.025) 45%, transparent 47%),
                conic-gradient(from 185deg at 75% 0%, transparent 41%, rgba(120,160,220,0.02) 44%, transparent 47%);
            animation: causticsShift 18s ease-in-out infinite;
            filter: blur(1px);
        }
        @keyframes causticsShift {
            0%,100% { transform: scaleX(1); opacity: 0.25; }
            33% { transform: scaleX(1.03) translateX(-0.5%); opacity: 0.3; }
            66% { transform: scaleX(0.98) translateX(0.5%); opacity: 0.2; }
        }

        /* Floating particles (marine snow) */
        .marine-snow { position: fixed; inset: 0; pointer-events: none; z-index: 1; overflow: hidden; }
        .snow-particle {
            position: absolute; border-radius: 50%; opacity: 0;
            animation: snowFall linear infinite;
        }
        @keyframes snowFall {
            0% { opacity: 0; transform: translateY(-5vh) translateX(0); }
            10% { opacity: 0.4; }
            90% { opacity: 0.4; }
            100% { opacity: 0; transform: translateY(105vh) translateX(var(--drift)); }
        }

        /* ‚ïê‚ïê‚ïê‚ïê Header ‚ïê‚ïê‚ïê‚ïê */
        .aquarium-header {
            position: relative; z-index: 10;
            padding: 1.5rem 2rem;
            display: flex; align-items: center; justify-content: space-between;
            border-bottom: 1px solid rgba(56,189,248,0.06);
            background: rgba(2,8,16,0.7);
            backdrop-filter: blur(20px);
        }
        .header-left { display: flex; align-items: center; gap: 1rem; }
        .header-logo {
            display: flex; align-items: center; gap: 0.6rem;
            text-decoration: none; color: var(--t1);
        }
        .logo-icon {
            width: 36px; height: 36px; border-radius: 10px;
            background: linear-gradient(135deg, rgba(247,147,26,0.15), rgba(74,234,188,0.1));
            border: 1px solid rgba(247,147,26,0.2);
            display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; position: relative; overflow: hidden;
        }
        .logo-icon::after {
            content: ''; position: absolute; inset: 0;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.15), transparent 60%);
        }
        .logo-text { display: flex; flex-direction: column; line-height: 1.1; }
        .logo-text .brand { font-family: 'DM Serif Display', serif; font-size: 1.15rem; }
        .logo-text .sub { font-family: 'JetBrains Mono', monospace; font-size: 0.55rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--biolum); opacity: 0.8; }

        .header-status {
            display: flex; align-items: center; gap: 1.5rem;
        }
        .status-pill {
            display: flex; align-items: center; gap: 0.4rem;
            font-family: 'JetBrains Mono', monospace; font-size: 0.7rem;
            color: var(--t2); padding: 0.3rem 0.75rem;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.06);
            border-radius: 100px;
        }
        .status-pill .dot {
            width: 6px; height: 6px; border-radius: 50%;
            box-shadow: 0 0 8px currentColor;
        }
        .dot-live { background: #4ade80; color: #4ade80; }
        .dot-connecting { background: var(--gold); color: var(--gold); animation: dotBlink 1s ease-in-out infinite; }
        .dot-offline { background: #ef4444; color: #ef4444; }
        @keyframes dotBlink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

        .back-link {
            display: flex; align-items: center; gap: 0.4rem;
            text-decoration: none; color: var(--t3); font-size: 0.8rem;
            transition: color 0.3s;
        }
        .back-link:hover { color: var(--gold); }
        .back-link svg { width: 16px; height: 16px; }

        .fs-btn {
            display: flex; align-items: center; justify-content: center;
            width: 32px; height: 32px; border-radius: 8px;
            background: rgba(255,255,255,0.04);
            border: 1px solid rgba(255,255,255,0.08);
            color: var(--t2); cursor: pointer;
            transition: all 0.25s;
        }
        .fs-btn:hover { background: rgba(255,255,255,0.08); color: var(--gold); border-color: rgba(247,147,26,0.3); }
        .fs-btn svg { width: 16px; height: 16px; }

        /* Fullscreen mode */
        :fullscreen .aquarium-header { display: none; }
        :fullscreen .tank-wrapper { max-width: 100%; padding: 0; height: 100vh; }
        :fullscreen .tank { height: 100vh; max-height: 100vh; border-radius: 0; border: none; }
        :fullscreen .stats-bar { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; border-radius: 0; margin: 0; opacity: 0.85; }
        :fullscreen .stats-bar:hover { opacity: 1; }
        :fullscreen .feed-panel { position: fixed; top: 0.5rem; right: 0.5rem; z-index: 50; opacity: 0.7; max-height: 35vh; }
        :fullscreen .feed-panel:hover { opacity: 1; }
        :fullscreen .fs-exit-hint {
            display: flex; position: fixed; top: 0.5rem; left: 50%; transform: translateX(-50%);
            z-index: 60; font-family: 'JetBrains Mono', monospace; font-size: 0.6rem;
            color: var(--t3); background: rgba(0,0,0,0.5); padding: 0.25rem 0.75rem;
            border-radius: 100px; opacity: 0; animation: hintFade 4s ease-in-out;
            pointer-events: none;
        }
        /* Webkit prefix for Safari */
        :-webkit-full-screen .aquarium-header { display: none; }
        :-webkit-full-screen .tank-wrapper { max-width: 100%; padding: 0; height: 100vh; }
        :-webkit-full-screen .tank { height: 100vh; max-height: 100vh; border-radius: 0; border: none; }
        :-webkit-full-screen .stats-bar { position: fixed; bottom: 0; left: 0; right: 0; z-index: 50; border-radius: 0; margin: 0; opacity: 0.85; }
        :-webkit-full-screen .feed-panel { position: fixed; top: 0.5rem; right: 0.5rem; z-index: 50; opacity: 0.7; max-height: 35vh; }
        :-webkit-full-screen .fs-exit-hint {
            display: flex; position: fixed; top: 0.5rem; left: 50%; transform: translateX(-50%);
            z-index: 60; pointer-events: none;
        }
        @keyframes hintFade { 0% { opacity: 0; } 10% { opacity: 0.8; } 70% { opacity: 0.8; } 100% { opacity: 0; } }
        .fs-exit-hint { display: none; }

        /* ‚ïê‚ïê‚ïê‚ïê Main Tank ‚ïê‚ïê‚ïê‚ïê */
        .tank-wrapper {
            position: relative; z-index: 5;
            margin: 0 auto;
            max-width: 1400px;
            padding: 1.5rem 2rem;
        }

        .tank {
            position: relative;
            width: 100%;
            height: 65vh;
            min-height: 400px;
            max-height: 700px;
            border-radius: 20px;
            overflow: hidden;
            border: 1px solid rgba(56,189,248,0.06);
            box-shadow:
                0 0 120px rgba(56,189,248,0.03),
                0 40px 100px rgba(0,0,0,0.6),
                inset 0 0 200px rgba(0,0,0,0.5),
                inset 0 1px 0 rgba(56,189,248,0.05);
            background: linear-gradient(180deg,
                #071422 0%,
                #040E1A 15%,
                #030A14 40%,
                #020710 70%,
                #010408 100%);
            cursor: crosshair;
        }

        /* Glass reflection ‚Äî top-left highlight, bottom-right subtle */
        .tank::before {
            content: ''; position: absolute; inset: 0; z-index: 100; pointer-events: none;
            border-radius: 20px;
            background:
                linear-gradient(155deg, rgba(56,189,248,0.05) 0%, rgba(56,189,248,0.01) 15%, transparent 35%),
                linear-gradient(200deg, transparent 65%, rgba(74,234,188,0.015) 100%),
                radial-gradient(ellipse 80% 40% at 50% 100%, rgba(20,15,8,0.4), transparent);
        }
        /* Vignette */
        .tank::after {
            content: ''; position: absolute; inset: 0; z-index: 3; pointer-events: none;
            border-radius: 20px;
            background: radial-gradient(ellipse 70% 65% at 50% 45%, transparent 50%, rgba(1,4,8,0.6) 100%);
        }

        .tank-canvas {
            position: absolute; inset: 0;
            width: 100%; height: 100%;
        }

        /* Tank overlay UI */
        .tank-overlay {
            position: absolute; inset: 0; z-index: 50; pointer-events: none;
            padding: 1.25rem;
        }

        .tank-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem; letter-spacing: 0.12em;
            text-transform: uppercase; color: rgba(56,189,248,0.4);
        }

        .tank-stats {
            position: absolute; top: 1.25rem; right: 1.25rem;
            display: flex; flex-direction: column; gap: 0.4rem;
            align-items: flex-end;
        }
        .tank-stat {
            font-family: 'JetBrains Mono', monospace; font-size: 0.65rem;
            color: rgba(232,237,245,0.5);
            background: rgba(0,0,0,0.3);
            padding: 0.2rem 0.5rem; border-radius: 4px;
            backdrop-filter: blur(4px);
        }
        .tank-stat strong { color: var(--biolum); font-weight: 600; }

        /* Depth markers */

        /* Block mined flash overlay */
        .block-flash-overlay {
            position: absolute; inset: 0; z-index: 90; pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
            background: radial-gradient(ellipse at 50% 50%, rgba(247,147,26,0.15), transparent 70%);
        }
        .block-flash-overlay.active {
            animation: blockFlash 2s ease-out forwards;
        }
        @keyframes blockFlash {
            0% { opacity: 1; }
            20% { opacity: 0.8; }
            100% { opacity: 0; }
        }

        /* ‚ïê‚ïê‚ïê‚ïê RBF Alert System ‚ïê‚ïê‚ïê‚ïê */

        /* Tank shake */
        @keyframes tankShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-4px) rotate(-0.3deg); }
            20% { transform: translateX(5px) rotate(0.4deg); }
            30% { transform: translateX(-6px) rotate(-0.2deg); }
            40% { transform: translateX(4px) rotate(0.3deg); }
            50% { transform: translateX(-3px) rotate(-0.15deg); }
            60% { transform: translateX(3px) rotate(0.2deg); }
            70% { transform: translateX(-2px) rotate(-0.1deg); }
            80% { transform: translateX(2px) rotate(0.1deg); }
            90% { transform: translateX(-1px); }
        }
        .tank.rbf-shake {
            animation: tankShake 0.7s ease-out;
        }

        /* Red flash overlay inside tank */
        .rbf-flash-overlay {
            position: absolute; inset: 0; z-index: 91; pointer-events: none;
            opacity: 0;
            background: radial-gradient(ellipse at 50% 50%, rgba(230,70,50,0.2), rgba(230,70,50,0.05) 60%, transparent 80%);
            border-radius: inherit;
        }
        .rbf-flash-overlay.active {
            animation: rbfFlash 2.5s ease-out forwards;
        }
        @keyframes rbfFlash {
            0% { opacity: 1; }
            15% { opacity: 0.7; }
            30% { opacity: 0.9; }
            50% { opacity: 0.5; }
            100% { opacity: 0; }
        }

        /* Warning banner above tank */
        .rbf-warning {
            position: absolute;
            top: 0; left: 50%; transform: translateX(-50%);
            z-index: 100;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: #fff;
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 40%, #c0392b 100%);
            padding: 0.5rem 1.5rem;
            border-radius: 6px 6px 0 0;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            box-shadow:
                0 -4px 20px rgba(230,70,50,0.4),
                0 0 40px rgba(230,70,50,0.15),
                inset 0 1px 0 rgba(255,255,255,0.15);
            transition: opacity 0.2s;
        }
        .rbf-warning.visible {
            animation: rbfWarningIn 3.5s ease-out forwards;
        }
        @keyframes rbfWarningIn {
            0%   { opacity: 0; transform: translateX(-50%) scale(0.9); }
            8%   { opacity: 1; transform: translateX(-50%) scale(1.05); }
            15%  { transform: translateX(-50%) scale(1); }
            20%, 80% { opacity: 1; }
            100% { opacity: 0; }
        }
        .rbf-warning .warn-icon {
            display: inline-block;
            animation: warnFlash 0.4s step-end 6;
        }
        @keyframes warnFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.2; }
        }
        .rbf-warning .warn-text {
            display: inline-block;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        /* Red border pulse on tank during RBF */
        .tank.rbf-active {
            box-shadow:
                inset 0 0 0 2px rgba(230,70,50,0.4),
                0 4px 30px rgba(0,0,0,0.4),
                0 0 60px rgba(230,70,50,0.1);
            transition: box-shadow 0.3s;
        }

        /* ‚ïê‚ïê‚ïê‚ïê Control Panel ‚ïê‚ïê‚ïê‚ïê */
        .controls {
            position: relative; z-index: 10;
            max-width: 1400px; margin: 0 auto;
            padding: 0 2rem 1.5rem;
            display: grid; grid-template-columns: 1fr 1fr 1fr;
            gap: 1rem;
        }

        .control-panel {
            background: rgba(15,31,53,0.5);
            border: 1px solid rgba(56,189,248,0.06);
            border-radius: 14px; padding: 1.25rem;
            backdrop-filter: blur(12px);
        }
        .control-panel-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem; letter-spacing: 0.1em;
            text-transform: uppercase; color: var(--biolum);
            margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.4rem;
        }
        .control-panel-title svg { width: 14px; height: 14px; stroke: var(--biolum); fill: none; stroke-width: 2; }

        /* Legend */
        .legend-items { display: flex; flex-direction: column; gap: 0.5rem; }
        .legend-item {
            display: flex; align-items: center; gap: 0.6rem;
            font-size: 0.78rem; color: var(--t2);
        }
        .legend-fish {
            width: 28px; height: 12px; border-radius: 50%;
            position: relative; flex-shrink: 0;
        }
        .legend-fish::after {
            content: ''; position: absolute; right: -4px; top: 2px;
            width: 0; height: 0;
            border-top: 4px solid transparent; border-bottom: 4px solid transparent;
            border-left: 6px solid;
            border-left-color: inherit;
        }
        .legend-fish.low { background: var(--fee-low); border-left-color: var(--fee-low); }
        .legend-fish.med { background: var(--fee-med); border-left-color: var(--fee-med); }
        .legend-fish.high { background: var(--fee-high); border-left-color: var(--fee-high); }
        .legend-fish.urgent { background: var(--fee-urgent); border-left-color: var(--fee-urgent); }

        /* Stats panel */
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.6rem; }
        .stat-box { text-align: center; }
        .stat-value {
            font-family: 'JetBrains Mono', monospace; font-size: 1.1rem;
            font-weight: 600; color: var(--t1);
        }
        .stat-value.gold { color: var(--gold); }
        .stat-value.cyan { color: var(--biolum); }
        .stat-label {
            font-size: 0.65rem; color: var(--t3);
            text-transform: uppercase; letter-spacing: 0.06em;
        }

        /* Activity Feed */
        .feed-container {
            height: 160px; overflow-y: auto; overflow-x: hidden;
            display: flex; flex-direction: column; gap: 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(56,189,248,0.15) transparent;
        }
        .feed-container::-webkit-scrollbar { width: 4px; }
        .feed-container::-webkit-scrollbar-track { background: transparent; }
        .feed-container::-webkit-scrollbar-thumb { background: rgba(56,189,248,0.15); border-radius: 2px; }
        .feed-empty {
            font-family: 'JetBrains Mono', monospace; font-size: 0.68rem;
            color: var(--t3); text-align: center; padding: 2rem 0;
            animation: dotBlink 2s ease-in-out infinite;
        }
        .feed-item {
            display: flex; align-items: flex-start; gap: 0.5rem;
            padding: 0.35rem 0; border-bottom: 1px solid rgba(56,189,248,0.04);
            animation: feedSlideIn 0.3s ease-out;
            flex-shrink: 0;
        }
        @keyframes feedSlideIn {
            from { opacity: 0; transform: translateY(-6px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .feed-icon {
            flex-shrink: 0; width: 18px; height: 18px;
            border-radius: 5px; display: flex; align-items: center;
            justify-content: center; font-size: 0.6rem; margin-top: 1px;
        }
        .feed-icon.tx { background: rgba(247,147,26,0.1); }
        .feed-icon.block { background: rgba(74,234,188,0.1); }
        .feed-icon.info { background: rgba(56,189,248,0.1); }
        .feed-text {
            font-family: 'JetBrains Mono', monospace; font-size: 0.65rem;
            color: var(--t2); line-height: 1.45; flex: 1; min-width: 0;
        }
        .feed-text .feed-val { color: var(--gold); font-weight: 600; }
        .feed-text .feed-block { color: var(--biolum); font-weight: 600; }
        .feed-text .feed-fee { color: var(--fee-med); }
        .feed-time {
            font-family: 'JetBrains Mono', monospace; font-size: 0.55rem;
            color: var(--t3); flex-shrink: 0; margin-top: 2px;
        }

        /* ‚ïê‚ïê‚ïê‚ïê Tooltip ‚ïê‚ïê‚ïê‚ïê */
        .fish-tooltip {
            position: fixed; z-index: 200; pointer-events: none;
            background: rgba(4,14,26,0.92);
            border: 1px solid rgba(56,189,248,0.15);
            border-radius: 10px; padding: 0.75rem 1rem;
            backdrop-filter: blur(16px);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.68rem; color: var(--t2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 30px rgba(56,189,248,0.04);
            opacity: 0; transition: opacity 0.2s;
            max-width: 260px;
            line-height: 1.6;
        }
        .fish-tooltip.visible { opacity: 1; }
        .fish-tooltip .tt-value { color: var(--gold); font-weight: 600; font-size: 0.85rem; }
        .fish-tooltip .tt-label { color: var(--t3); }
        .fish-tooltip .tt-fee { color: var(--fee-med); }
        .fish-tooltip .tt-hash { color: var(--t3); font-size: 0.55rem; word-break: break-all; opacity: 0.6; }

        /* ‚ïê‚ïê‚ïê‚ïê Block mined notification ‚ïê‚ïê‚ïê‚ïê */
        .block-notif {
            position: fixed; top: 5rem; left: 50%; transform: translateX(-50%) translateY(-20px);
            z-index: 500;
            background: rgba(4,14,26,0.9);
            border: 1px solid rgba(247,147,26,0.3);
            border-radius: 12px; padding: 1rem 1.5rem;
            backdrop-filter: blur(16px);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5), 0 0 40px rgba(247,147,26,0.08);
            display: flex; align-items: center; gap: 0.75rem;
            opacity: 0; pointer-events: none;
            transition: opacity 0.4s, transform 0.4s;
        }
        .block-notif.show {
            opacity: 1; transform: translateX(-50%) translateY(0);
        }
        .block-notif-icon {
            width: 40px; height: 40px; border-radius: 10px;
            background: rgba(247,147,26,0.1);
            border: 1px solid rgba(247,147,26,0.2);
            display: flex; align-items: center; justify-content: center;
            font-size: 1.3rem;
        }
        .block-notif-text { display: flex; flex-direction: column; }
        .block-notif-title {
            font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;
            font-weight: 600; color: var(--gold); letter-spacing: 0.03em;
        }
        .block-notif-detail {
            font-size: 0.7rem; color: var(--t2);
        }

        /* ‚ïê‚ïê‚ïê‚ïê Responsive ‚ïê‚ïê‚ïê‚ïê */
        @media (max-width: 900px) {
            .controls { grid-template-columns: 1fr; }
            .tank { height: 55vh; min-height: 320px; }
            .aquarium-header { padding: 1rem 1.25rem; flex-wrap: wrap; gap: 0.5rem; }
            .header-status { gap: 0.75rem; }
            .tank-wrapper { padding: 1rem 1rem; }
            .controls { padding: 0 1rem 1rem; }
        }
        @media (max-width: 600px) {
            .tank { height: 50vh; min-height: 280px; border-radius: 14px; }
            .controls { gap: 0.75rem; }
            .control-panel { padding: 1rem; }
            .back-link span { display: none; }
            .status-pill { font-size: 0.6rem; padding: 0.25rem 0.6rem; }
        }

        /* ‚ïê‚ïê‚ïê‚ïê Event Trigger Panel ‚ïê‚ïê‚ïê‚ïê */
        .event-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.35rem;
        }
        .evt-btn {
            background: rgba(56,189,248,0.04);
            border: 1px solid rgba(56,189,248,0.1);
            border-radius: 6px;
            padding: 0.35rem 0.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            color: var(--t2);
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .evt-btn:hover {
            background: rgba(56,189,248,0.1);
            border-color: rgba(56,189,248,0.25);
            color: var(--biolum);
        }
        .evt-btn:active {
            background: rgba(56,189,248,0.18);
            transform: scale(0.97);
        }
        .evt-btn.evt-whale {
            grid-column: 1 / -1;
            background: rgba(247,147,26,0.06);
            border-color: rgba(247,147,26,0.15);
            text-align: center;
            color: var(--gold);
        }
        .evt-btn.evt-whale:hover {
            background: rgba(247,147,26,0.14);
            border-color: rgba(247,147,26,0.3);
        }
        .panel-toggle {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(4,14,26,0.3);
            border: 1px solid rgba(56,189,248,0.05);
            color: rgba(56,189,248,0.15);
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            transition: all 0.35s;
            user-select: none;
            opacity: 0.35;
        }
        .panel-toggle:hover {
            opacity: 1;
            border-color: rgba(56,189,248,0.25);
            color: var(--biolum);
            background: rgba(4,14,26,0.65);
        }
        .panel-toggle.active {
            opacity: 0.7;
            background: rgba(56,189,248,0.06);
            border-color: rgba(56,189,248,0.15);
            color: var(--biolum);
        }

        .feed-btn {
            position: absolute;
            bottom: 10px;
            right: 46px;
            z-index: 200;
            height: 26px;
            padding: 0 10px 0 7px;
            border-radius: 13px;
            border: 1px solid rgba(251,191,36,0.06);
            background: rgba(4,14,26,0.3);
            color: rgba(251,191,36,0.25);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.62rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
            letter-spacing: 0.03em;
            transition: all 0.35s;
            user-select: none;
            opacity: 0.35;
        }
        .feed-btn:hover {
            opacity: 1;
            background: rgba(4,14,26,0.65);
            color: #fbbf24;
            border-color: rgba(251,191,36,0.25);
        }
        .feed-btn:active { transform: scale(0.95); }
        .feed-btn .feed-icon { font-size: 0.8rem; line-height: 1; }

    </style>
</head>
<body>

<div class="ocean-bg"></div>
<div class="caustics"></div>
<div class="marine-snow" id="marineSnow"></div>

<!-- Tooltip -->
<div class="fish-tooltip" id="tooltip"></div>

<!-- Block mined notification -->
<div class="block-notif" id="blockNotif">
    <div class="block-notif-icon">‚õè</div>
    <div class="block-notif-text">
        <div class="block-notif-title" id="notifTitle">Block Mined!</div>
        <div class="block-notif-detail" id="notifDetail"></div>
    </div>
</div>

<!-- Header -->
<header class="aquarium-header">
    <div class="header-left">
        <a href="index.html" class="header-logo">
            <div class="logo-icon">üêü</div>
            <div class="logo-text">
                <span class="brand">Mempool Aquarium</span>
                <span class="sub">BC2 Network ‚Äî Live</span>
            </div>
        </a>
    </div>
    <div class="header-status">
        <div class="status-pill" id="statusPill">
            <span class="dot dot-connecting" id="statusDot"></span>
            <span id="statusText">Connecting‚Ä¶</span>
        </div>
        <a href="index.html" class="back-link">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
            <span>GenesisWallet</span>
        </a>
        <button class="fs-btn" id="fsBtn" title="Toggle fullscreen">
            <svg id="fsIconExpand" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 00-2 2v3m18 0V5a2 2 0 00-2-2h-3m0 18h3a2 2 0 002-2v-3M3 16v3a2 2 0 002 2h3"/></svg>
            <svg id="fsIconShrink" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="display:none"><path d="M4 14h4v4m12-4h-4v4M4 10h4V6m12 4h-4V6"/></svg>
        </button>
    </div>
</header>
<div class="fs-exit-hint" id="fsHint">Press ESC to exit fullscreen</div>

<!-- Tank -->
<div class="tank-wrapper">
    <!-- RBF Warning banner ‚Äî outside tank to avoid overflow clip -->
    <div class="rbf-warning" id="rbfWarning">
        <span class="warn-icon">‚ö†</span>
        <span class="warn-text"> A BIGGER FISH LURKS!</span>
        <span class="warn-icon">‚ö†</span>
    </div>

    <div class="tank" id="tank">
        <canvas class="tank-canvas" id="tankCanvas"></canvas>

        <!-- Flash overlay for block events -->
        <div class="block-flash-overlay" id="blockFlash"></div>

        <!-- Flash overlay for RBF events -->
        <div class="rbf-flash-overlay" id="rbfFlash"></div>

        <!-- Overlay info -->
        <div class="tank-overlay">
            <div class="tank-title">‚óÜ BC2 Mempool ‚Äî Transaction Aquarium</div>
            <div class="tank-stats">
                <div class="tank-stat"><strong id="fishCount">0</strong> creatures</div>
                <div class="tank-stat">Block <strong id="nextBlock">‚Äî</strong></div>
                <div class="tank-stat" id="lastBlockStat" style="display:none">Last: <strong id="lastBlockTime">‚Äî</strong></div>
            </div>
        </div>

        <!-- Feed button (inside tank) -->
        <button class="feed-btn" id="feedBtn" onclick="window._dropFood()">
            <span class="feed-icon">üêü</span> Feed
        </button>

        <!-- Event toggle (inside tank) -->
        <div class="panel-toggle" id="panelToggle" onclick="document.getElementById('eventPanel').style.display=document.getElementById('eventPanel').style.display==='none'?'block':'none'; this.classList.toggle('active');">
            ‚ö°
        </div>
    </div>
</div>

<!-- Controls -->
<div class="controls">
    <!-- Legend -->
    <div class="control-panel">
        <div class="control-panel-title">
            <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg>
            Creature Guide
        </div>
        <div class="legend-items">
            <div class="legend-item"><div class="legend-fish low"></div>Low fee (1‚Äì2 sat2/vB) ‚Äî Drifters</div>
            <div class="legend-item"><div class="legend-fish med"></div>Medium fee (3‚Äì10 sat2/vB) ‚Äî Swimmers</div>
            <div class="legend-item"><div class="legend-fish high"></div>High fee (11‚Äì50 sat2/vB) ‚Äî Sprinters</div>
            <div class="legend-item"><div class="legend-fish urgent"></div>Urgent fee (50+ sat2/vB) ‚Äî Blazers</div>
            <div class="legend-item" style="margin-top:0.3rem;font-size:0.7rem;color:var(--t3);">
                Size = transaction value &nbsp;¬∑&nbsp; Speed = fee priority<br>
                Click tank to inspect &nbsp;¬∑&nbsp; Hover a fish for details
            </div>
        </div>
    </div>

    <!-- Network stats -->
    <div class="control-panel">
        <div class="control-panel-title">
            <svg viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
            Network Vitals
        </div>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value gold" id="statTxCount">‚Äî</div>
                <div class="stat-label">Mempool TXs</div>
            </div>
            <div class="stat-box">
                <div class="stat-value cyan" id="statMempoolSize">‚Äî</div>
                <div class="stat-label">Mempool Size</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="statLowFee">‚Äî</div>
                <div class="stat-label">Low Fee</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="statMedFee">‚Äî</div>
                <div class="stat-label">Med Fee</div>
            </div>
        </div>
    </div>

    <!-- Activity Feed -->
    <div class="control-panel">
        <div class="control-panel-title">
            <svg viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/></svg>
            Live Activity
        </div>
        <div class="feed-container" id="feedContainer">
            <div class="feed-empty">Waiting for network events‚Ä¶</div>
        </div>
    </div>

    <!-- Event Trigger Panel (hidden by default) -->
    <div class="control-panel" id="eventPanel" style="display:none;">
        <div class="control-panel-title" style="cursor:default;">
            <svg viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10"/></svg>
            Event Triggers
        </div>
        <div class="event-grid">
            <button class="evt-btn" onclick="window._trigEvt('addFish')">üêü Add Fish</button>
            <button class="evt-btn" onclick="window._trigEvt('bubbleVent')">ü´ß Bubble Vent</button>
            <button class="evt-btn" onclick="window._trigEvt('schooling')">üêü Schooling</button>
            <button class="evt-btn" onclick="window._trigEvt('biolumPulse')">‚ú® Biolum Pulse</button>
            <button class="evt-btn" onclick="window._trigEvt('jellyfish')">ü™º Jellyfish</button>
            <button class="evt-btn" onclick="window._trigEvt('predatorChase')">ü¶à Predator</button>
            <button class="evt-btn" onclick="window._trigEvt('currentSweep')">üåä Current Sweep</button>
            <button class="evt-btn" onclick="window._trigEvt('baitball')">üêü Baitball</button>
            <button class="evt-btn" onclick="window._trigEvt('hermitCrab')">ü¶Ä Hermit Crab</button>
            <button class="evt-btn" onclick="window._trigEvt('treasureDrop')">ü™ô Treasure Drop</button>
            <button class="evt-btn" onclick="window._trigEvt('tideChange')">üåä Tide Change</button>
            <button class="evt-btn" onclick="window._trigEvt('planktonBloom')">ü¶† Plankton Bloom</button>
            <button class="evt-btn" onclick="window._trigEvt('electricEel')">‚ö° Electric Eel</button>
            <button class="evt-btn" onclick="window._trigEvt('anglerfish')">ü™º Anglerfish</button>
            <button class="evt-btn" onclick="window._trigEvt('seaTurtle')">üê¢ Sea Turtle</button>
            <button class="evt-btn" onclick="window._trigEvt('seaquake')">üåã Seaquake</button>
            <button class="evt-btn" onclick="window._trigEvt('mantaRay')">ü¶à Manta Ray</button>
            <button class="evt-btn" onclick="window._trigEvt('aurora')">‚ú® Aurora</button>
            <button class="evt-btn" onclick="window._trigEvt('lightningStrike')">‚ö° Lightning</button>
            <button class="evt-btn" onclick="window._trigEvt('krakenTentacle')">ü¶ë Kraken</button>
            <button class="evt-btn" onclick="window._trigEvt('bottleMessage')">üìú Bottle Msg</button>
            <button class="evt-btn" onclick="window._trigEvt('satoshiGhost')">üëÅ Satoshi Ghost</button>
            <button class="evt-btn evt-whale" onclick="window._trigEvt('whale')">üêã Whale (Block)</button>
        </div>
    </div>
</div>


<script>
(function() {
    'use strict';

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CONFIGURATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var HOSTS = ['https://bc2.live', 'https://bitcoinii.space'];
    var activeHost = null;
    var MAX_FISH = 2000;
    var WHALE_DURATION = 6500;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  CANVAS SETUP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var canvas = document.getElementById('tankCanvas');
    var ctx = canvas.getContext('2d');
    var dpr = window.devicePixelRatio || 1;
    var W = 0, H = 0;

    function resize() {
        var rect = canvas.parentElement.getBoundingClientRect();
        W = rect.width;
        H = rect.height;
        canvas.width = W * dpr;
        canvas.height = H * dpr;
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    resize();
    window.addEventListener('resize', resize);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FISH DATA
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var bc2Logo = new Image();
    bc2Logo.src = 'data:image/png;base64,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';

    var fishes = [];
    var nextFishId = 0;

    // Fee rate ‚Üí color
    function feeColor(feeRate) {
        if (feeRate <= 2) return { r: 247, g: 147, b: 26, hex: '#F7931A' };    // gold
        if (feeRate <= 10) return { r: 249, g: 115, b: 22, hex: '#F97316' };   // orange
        if (feeRate <= 50) return { r: 239, g: 68, b: 68, hex: '#EF4444' };    // red
        return { r: 220, g: 38, b: 38, hex: '#DC2626' };                        // deep red
    }

    // Value ‚Üí fish size (logarithmic)
    function valueToSize(valueSat) {
        var btc = valueSat / 1e8;
        if (btc <= 0) btc = 0.001;
        var s = 8 + Math.log10(btc + 0.001) * 8 + Math.sqrt(btc) * 3;
        return Math.max(6, Math.min(40, s));
    }

    // Fee ‚Üí speed
    function feeToSpeed(feeRate) {
        return 0.3 + Math.min(feeRate, 100) * 0.02;
    }

    // txid ‚Üí fish lookup for RBF detection
    var txidMap = {};
    function registerFish(f) {
        if (f.txid) txidMap[f.txid] = f;
    }
    function unregisterFish(f) {
        if (f.txid && txidMap[f.txid] === f) delete txidMap[f.txid];
    }

    function createFish(opts) {
        var fee = opts.feeRate || 1;
        var val = opts.value || 50000;
        var col = feeColor(fee);
        var size = valueToSize(val);
        var speed = feeToSpeed(fee);
        var dir = Math.random() > 0.5 ? 1 : -1;

        // Priority zones: high fee fish swim higher (toward surface)
        var yZone;
        if (fee > 50) yZone = 0.05 + Math.random() * 0.25;
        else if (fee > 10) yZone = 0.15 + Math.random() * 0.35;
        else if (fee > 2) yZone = 0.3 + Math.random() * 0.4;
        else yZone = 0.5 + Math.random() * 0.45;

        var fish = {
            id: nextFishId++,
            txid: opts.txid || ('sim_' + Math.random().toString(36).substr(2, 12)),
            value: val,
            feeRate: fee,
            size: size,
            color: col,
            x: opts.spawnX != null ? opts.spawnX : (dir > 0 ? -size * 2 : W + size * 2),
            y: opts.spawnY != null ? opts.spawnY : (yZone * H),
            vx: speed * dir,
            vy: (Math.random() - 0.5) * 0.3,
            dir: dir,
            tailPhase: Math.random() * Math.PI * 2,
            tailSpeed: 3 + speed * 2,
            glowPhase: Math.random() * Math.PI * 2,
            alive: true,
            age: 0,
            scooped: false,
            scoopTime: 0,
            isUser: opts.isUser || false,
            // Base speed ‚Äî for restoration after events
            baseVx: speed * dir,
            baseTailSpeed: 3 + speed * 2,
            baseSpeed: speed,
            // RBF
            isRbf: false,
            rbfEaten: false,
            rbfHunted: false,
            huntTarget: null,
            huntPhase: 0,
            // Wander behavior
            wanderAngle: Math.random() * Math.PI * 2,
            wanderTimer: Math.random() * 200,
            yTarget: yZone * H,
            // Smooth rotation
            tilt: 0,
        };
        registerFish(fish);
        return fish;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  WHALE (block mined event)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var whale = null;
    var whaleCleanupPending = false;
    var lastBlockMinedAt = 0; // Timestamp of last block ‚Äî used to delay re-fetch so mempool API can update
    var POST_BLOCK_COOLDOWN = 10000; // 10s grace period before re-fetching mempool after a block

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  RBF ‚Äî Replace-By-Fee predator system
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function spawnRbfPredator(newTxid, oldTxid, newFee, newValue) {
        if (whale || whaleCleanupPending) return;
        var prey = txidMap[oldTxid];
        if (!prey || prey.scooped || prey.rbfEaten) return;

        // Mark prey as being hunted
        prey.rbfHunted = true;

        // Spawn predator from edge, aimed at prey
        var spawnSide = Math.random() > 0.5 ? 1 : -1;
        var predator = createFish({
            txid: newTxid,
            feeRate: newFee || (prey.feeRate * 1.5 + 2),
            value: newValue || prey.value,
            spawnX: spawnSide > 0 ? -30 : W + 30,
            spawnY: prey.y + (Math.random() - 0.5) * 60,
        });

        // RBF predator properties
        predator.isRbf = true;
        predator.huntTarget = prey;
        predator.huntPhase = 0;  // 0=chasing, 1=eating, 2=done
        predator.rbfOldTxid = oldTxid;

        // Redder color ‚Äî shift toward warm red
        predator.color = { r: 230, g: 70, b: 50 };

        // Slightly bigger and faster than prey
        predator.size = Math.max(prey.size * 1.15, prey.size + 2);
        predator.vx = 0; // will be controlled by hunt logic
        predator.vy = 0;

        fishes.push(predator);
        registerFish(predator);
        updateFishCount();

        // Feed
        var shortOld = oldTxid.substring(0, 8) + '‚Ä¶';
        var shortNew = newTxid.substring(0, 8) + '‚Ä¶';
        var feeStr = Math.round(predator.feeRate) + ' sat2/vB';
        addFeedItem('info',
            '<span style="color:#e64632;">‚ö° RBF</span> ' +
            '<span style="color:var(--t3);font-size:0.55rem;">' + shortNew + '</span>' +
            ' replacing ' +
            '<span style="color:var(--t3);font-size:0.55rem;">' + shortOld + '</span>' +
            ' ¬∑ <span class="feed-fee">' + feeStr + '</span>'
        );

        // ‚îÄ‚îÄ Visual alerts ‚îÄ‚îÄ
        triggerRbfAlert();
    }

    function triggerRbfAlert() {
        var tank = document.getElementById('tank');
        var warning = document.getElementById('rbfWarning');
        var flash = document.getElementById('rbfFlash');

        // Shake the tank
        tank.classList.remove('rbf-shake');
        tank.classList.remove('rbf-active');
        void tank.offsetWidth; // force reflow
        tank.classList.add('rbf-shake');
        tank.classList.add('rbf-active');
        setTimeout(function() {
            tank.classList.remove('rbf-shake');
        }, 700);
        setTimeout(function() {
            tank.classList.remove('rbf-active');
        }, 3500);

        // Flash warning banner
        warning.classList.remove('visible');
        void warning.offsetWidth;
        warning.classList.add('visible');
        setTimeout(function() {
            warning.classList.remove('visible');
        }, 3600);

        // Red flash overlay
        flash.classList.remove('active');
        void flash.offsetWidth;
        flash.classList.add('active');
        setTimeout(function() {
            flash.classList.remove('active');
        }, 2600);
    }

    function updateRbfHunters(dt) {
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (!f.isRbf || !f.huntTarget || f.huntPhase >= 2) continue;

            var prey = f.huntTarget;

            if (f.huntPhase === 0) {
                // Chasing ‚Äî steer aggressively toward prey
                var dx = prey.x - f.x;
                var dy = prey.y - f.y;
                var dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < f.size * 0.8) {
                    // Caught! Start eating
                    f.huntPhase = 1;
                    f.eatStart = performance.now();
                    prey.rbfEaten = true;
                    prey.rbfEatTime = performance.now();
                    spawnBubble(prey.x, prey.y, 2);
                    spawnBubble(f.x, f.y, 1.5);
                } else {
                    // Chase with speed proportional to distance
                    var chaseSpeed = Math.min(4, 1.5 + dist * 0.005) * dt * 0.06;
                    f.x += (dx / dist) * chaseSpeed * dt;
                    f.y += (dy / dist) * chaseSpeed * dt;
                    f.dir = dx > 0 ? 1 : -1;
                    f.tailSpeed = 6 + dist * 0.02; // wiggle faster when chasing
                    // Smooth tilt toward prey
                    var huntTilt = Math.atan2(dy, Math.abs(dx) + 0.3);
                    huntTilt = Math.max(-0.8, Math.min(0.8, huntTilt));
                    f.tilt += (huntTilt - f.tilt) * 0.1 * dt;
                }
            }

            if (f.huntPhase === 1) {
                // Eating animation ‚Äî prey shrinks into predator
                var elapsed = (performance.now() - f.eatStart) / 1000;
                if (elapsed > 0.6) {
                    // Done eating ‚Äî predator becomes normal fish
                    f.huntPhase = 2;
                    f.isRbf = false;
                    f.huntTarget = null;

                    // Gradually shift color back toward normal (but keep slight red tint)
                    f.color = { r: 180, g: 120, b: 80 };
                    f.tailSpeed = 3 + Math.abs(f.vx) * 2;
                    f.vx = (Math.random() > 0.5 ? 1 : -1) * (0.5 + Math.random() * 1.2);
                    f.dir = f.vx > 0 ? 1 : -1;

                    // Remove prey from pool
                    unregisterFish(prey);
                    prey.alive = false;
                    updateFishCount();
                }
            }
        }
    }

    function spawnWhale(blockHeight, txCount) {
        var startX = -180;
        var endX = W + 200;
        whale = {
            x: startX,
            y: H * 0.35,
            targetX: endX,
            width: 160,
            height: 70,
            progress: 0,
            duration: WHALE_DURATION,
            startTime: performance.now(),
            blockHeight: blockHeight,
            txCount: txCount || 0,
            scoopedCount: 0,
            mouthOpen: 0,
        };

        // Flash
        var flash = document.getElementById('blockFlash');
        flash.classList.remove('active');
        void flash.offsetWidth;
        flash.classList.add('active');

        // Notification
        showBlockNotif(blockHeight, txCount);
    }

    function updateWhale(now) {
        if (!whale) return;
        var elapsed = now - whale.startTime;
        whale.progress = Math.min(1, elapsed / whale.duration);

        // Ease in-out
        var t = whale.progress;
        var ease = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

        whale.x = -180 + ease * (whale.targetX + 180);
        whale.y = H * 0.4 + Math.sin(t * Math.PI * 2) * 40;
        whale.mouthOpen = 0.3 + Math.sin(t * Math.PI * 6) * 0.3;

        // Sediment kick ‚Äî whale disturbs the seabed as it passes
        if (!whale._lastSedX) whale._lastSedX = whale.x;
        if (whale.x - whale._lastSedX > 35) {
            spawnSediment(whale.x + whale.width * 0.5);
            whale._lastSedX = whale.x;
        }

        // Scoop ALL fish the whale's leading edge has passed
        // The mouth is on the RIGHT side (front), so scoop anything behind the mouth
        var mouthX = whale.x + whale.width;
        for (var i = fishes.length - 1; i >= 0; i--) {
            var f = fishes[i];
            if (f.scooped) continue;
            // Scoop any fish whose x position is behind the whale's mouth
            // Full tank height ‚Äî the whale is a wall sweeping across
            if (f.x < mouthX - whale.width * 0.3) {
                f.scooped = true;
                f.scoopTime = now;
                whale.scoopedCount++;
            }
        }

        if (whale.progress >= 1) {
            // Scoop any remaining stragglers
            for (var i = 0; i < fishes.length; i++) {
                if (!fishes[i].scooped) {
                    fishes[i].scooped = true;
                    fishes[i].scoopTime = now;
                }
            }
            // Small delay then wipe tank clean and re-fetch
            whaleCleanupPending = true;
            setTimeout(function() {
                // Nuclear cleanup ‚Äî remove ALL fish
                fishes.length = 0;
                // Clear txid lookup
                for (var k in txidMap) { delete txidMap[k]; }
                // Clear active events
                if (predator) {
                    if (predator.prey && predator.prey.alive) {
                        predator.prey._scared = false;
                        predator.prey.tailSpeed = predator.prey.baseTailSpeed || 4;
                    }
                    predator = null;
                }
                if (anglerfish) anglerfish = null;
                if (baitball) baitball = null;
                if (schoolEvent) {
                    schoolEvent.fish.forEach(function(f) { f._schooling = false; });
                    schoolEvent = null;
                }
                if (currentSweep) currentSweep = null;
                if (biolumPulse) biolumPulse = null;
                if (activeVent) { activeVent = null; ventActive = false; }
                if (seaTurtle) seaTurtle = null;
                if (electricEel) {
                    electricEel.stunned.forEach(function(sf) { sf._stunned = false; });
                    electricEel = null;
                }
                if (mantaRay) mantaRay = null;
                if (hermitCrab) hermitCrab = null;
                if (tideChange) tideChange = null;
                whale = null;
                whaleCleanupPending = false;
                lastBlockMinedAt = Date.now();
                updateFishCount();
                // Delay re-populate so the mempool API has time to drop confirmed txns
                setTimeout(function() {
                    fetchMempoolRecent();
                }, POST_BLOCK_COOLDOWN);
            }, 1200);
        }
    }

    function drawWhale() {
        if (!whale) return;
        ctx.save();
        // Clip to tank bounds so glow never bleeds outside
        ctx.beginPath();
        ctx.rect(0, 0, W, H);
        ctx.clip();

        var wx = whale.x;
        var wy = whale.y;
        var w = whale.width;
        var h = whale.height;
        var mouth = whale.mouthOpen;

        // Draw a sweeping "net" curtain behind the whale ‚Äî full tank height
        var netAlpha = 0.04 + whale.progress * 0.02;
        var netStartX = Math.max(0, wx + w);
        var netEndX = Math.max(0, wx - 40);
        if (netStartX > netEndX) {
            var netGrad = ctx.createLinearGradient(netStartX, 0, netEndX, 0);
            netGrad.addColorStop(0, 'rgba(247,147,26,' + netAlpha.toFixed(3) + ')');
            netGrad.addColorStop(1, 'rgba(247,147,26,0)');
            ctx.fillStyle = netGrad;
            ctx.fillRect(netEndX, 0, netStartX - netEndX, H);
        }

        ctx.translate(wx, wy);

        // Body glow ‚Äî clamped radius so it fades naturally
        var glowCX = w * 0.5;
        var glowR = w * 0.8;
        var grd = ctx.createRadialGradient(glowCX, 0, 5, glowCX, 0, glowR);
        grd.addColorStop(0, 'rgba(247,147,26,0.18)');
        grd.addColorStop(0.6, 'rgba(247,147,26,0.06)');
        grd.addColorStop(1, 'rgba(247,147,26,0)');
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(glowCX, 0, glowR, 0, Math.PI * 2);
        ctx.fill();

        // Main body ‚Äî mouth on RIGHT, tail on LEFT
        ctx.beginPath();
        // Mouth right side (opening)
        ctx.moveTo(w, -h * 0.15 * mouth);
        // Top curve from mouth to back
        ctx.bezierCurveTo(w * 0.8, -h * 0.55, w * 0.4, -h * 0.6, w * 0.2, -h * 0.35);
        // Tail junction top
        ctx.bezierCurveTo(w * 0.08, -h * 0.2, 0, -h * 0.15, -w * 0.05, -h * 0.1);
        // Tail fin top
        ctx.lineTo(-w * 0.2, -h * 0.55);
        // Tail notch
        ctx.lineTo(-w * 0.08, 0);
        // Tail fin bottom
        ctx.lineTo(-w * 0.2, h * 0.55);
        // Tail junction bottom
        ctx.lineTo(-w * 0.05, h * 0.1);
        ctx.bezierCurveTo(0, h * 0.15, w * 0.08, h * 0.2, w * 0.2, h * 0.35);
        // Bottom curve from back to mouth
        ctx.bezierCurveTo(w * 0.4, h * 0.6, w * 0.8, h * 0.55, w, h * 0.15 * mouth);
        ctx.closePath();

        var bodyGrad = ctx.createLinearGradient(0, -h * 0.5, 0, h * 0.5);
        bodyGrad.addColorStop(0, 'rgba(247,147,26,0.18)');
        bodyGrad.addColorStop(0.5, 'rgba(247,147,26,0.1)');
        bodyGrad.addColorStop(1, 'rgba(184,134,11,0.12)');
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(247,147,26,0.45)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Belly highlight
        ctx.beginPath();
        ctx.ellipse(w * 0.5, h * 0.05, w * 0.3, h * 0.15, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fill();

        // Eye (near the mouth / front-right)
        ctx.beginPath();
        ctx.arc(w * 0.75, -h * 0.15, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(247,147,26,0.9)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(w * 0.76, -h * 0.15, 2.5, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        // Dorsal fin
        ctx.beginPath();
        ctx.moveTo(w * 0.5, -h * 0.5);
        ctx.quadraticCurveTo(w * 0.45, -h * 0.85, w * 0.3, -h * 0.55);
        ctx.lineTo(w * 0.38, -h * 0.45);
        ctx.closePath();
        ctx.fillStyle = 'rgba(247,147,26,0.15)';
        ctx.fill();

        // Pectoral fin
        ctx.beginPath();
        ctx.moveTo(w * 0.55, h * 0.25);
        ctx.quadraticCurveTo(w * 0.4, h * 0.55, w * 0.3, h * 0.35);
        ctx.lineTo(w * 0.42, h * 0.22);
        ctx.closePath();
        ctx.fillStyle = 'rgba(247,147,26,0.1)';
        ctx.fill();

        // Mouth line
        ctx.beginPath();
        ctx.moveTo(w * 0.98, -h * 0.02);
        ctx.quadraticCurveTo(w * 0.88, 0, w * 0.98, h * 0.02);
        ctx.strokeStyle = 'rgba(247,147,26,0.3)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Label
        ctx.font = '600 11px "JetBrains Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(247,147,26,0.8)';
        ctx.fillText('‚õè BLOCK #' + (whale.blockHeight || '?'), w * 0.45, h * 0.9);

        if (whale.scoopedCount > 0) {
            ctx.font = '500 9px "JetBrains Mono", monospace';
            ctx.fillStyle = 'rgba(247,147,26,0.5)';
            ctx.fillText(whale.scoopedCount + ' txns scooped', w * 0.45, h * 1.1);
        }

        ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FISH RENDERING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function drawFish(f, now) {
        var s = f.size;
        var col = f.color;

        if (f.scooped) {
            // Animate being scooped toward whale's mouth
            var st = (now - f.scoopTime) / 1000;
            if (st > 1) return;
            var alpha = 1 - st;
            ctx.globalAlpha = alpha * alpha;
            // Shrink and drift toward whale mouth (right side of whale)
            var targetX = whale ? whale.x + whale.width * 0.9 : f.x + 50;
            var targetY = whale ? whale.y : f.y;
            f.x += (targetX - f.x) * 0.06;
            f.y += (targetY - f.y) * 0.04;
            // Shrink the fish
            s *= (1 - st * 0.7);
            if (s < 1) { ctx.globalAlpha = 1; return; }
        }

        // RBF eaten ‚Äî shrink toward predator then vanish
        if (f.rbfEaten) {
            var rt = (now - f.rbfEatTime) / 1000;
            if (rt > 0.6) { ctx.globalAlpha = 1; return; }
            var alpha2 = 1 - rt / 0.6;
            ctx.globalAlpha = alpha2 * alpha2;
            s *= (1 - rt * 1.2);
            if (s < 1) { ctx.globalAlpha = 1; return; }
            // Flash red tint as being consumed
            col = { r: Math.min(255, col.r + 120), g: Math.max(0, col.g - 60), b: Math.max(0, col.b - 60) };
        }

        if (!f.alive) { ctx.globalAlpha = 1; return; }

        ctx.save();
        ctx.translate(f.x, f.y);
        if (f.dir < 0) ctx.scale(-1, 1);
        ctx.rotate(f.tilt || 0);

        // Tail wiggle
        var tailAngle = Math.sin(f.tailPhase) * 0.3;

        // Bioluminescent glow (boosted during pulse wave)
        var biolumBoost = f._biolumBoost || 0;
        var glowPulse = 0.5 + Math.sin(f.glowPhase) * 0.3 + biolumBoost;
        var glowRadius = s * (1.8 + glowPulse * 0.5 + biolumBoost * 2);
        var glow = ctx.createRadialGradient(0, 0, s * 0.2, 0, 0, glowRadius);
        glow.addColorStop(0, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',' + (0.12 * glowPulse).toFixed(3) + ')');
        glow.addColorStop(1, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
        ctx.fill();

        // User-spawned ring
        if (f.isUser) {
            var ringPulse = 0.4 + Math.sin(f.glowPhase * 1.5) * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, s * 1.5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(74,234,188,' + ringPulse.toFixed(2) + ')';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }

        // RBF predator ‚Äî pulsing red aura
        if (f.isRbf && f.huntPhase < 2) {
            var rbfPulse = 0.5 + Math.sin(f.glowPhase * 2.5) * 0.4;
            var rbfGlow = ctx.createRadialGradient(0, 0, s * 0.3, 0, 0, s * 2.2);
            rbfGlow.addColorStop(0, 'rgba(230,70,50,' + (0.15 * rbfPulse).toFixed(3) + ')');
            rbfGlow.addColorStop(0.5, 'rgba(230,70,50,' + (0.06 * rbfPulse).toFixed(3) + ')');
            rbfGlow.addColorStop(1, 'rgba(230,70,50,0)');
            ctx.fillStyle = rbfGlow;
            ctx.beginPath();
            ctx.arc(0, 0, s * 2.2, 0, Math.PI * 2);
            ctx.fill();
        }

        // Body
        ctx.beginPath();
        ctx.moveTo(s * 0.9, 0);
        ctx.bezierCurveTo(s * 0.7, -s * 0.45, -s * 0.3, -s * 0.4, -s * 0.5, -s * 0.15);
        ctx.bezierCurveTo(-s * 0.6, 0, -s * 0.6, 0, -s * 0.5, s * 0.15);
        ctx.bezierCurveTo(-s * 0.3, s * 0.4, s * 0.7, s * 0.45, s * 0.9, 0);
        ctx.closePath();

        var bodyGrad = ctx.createLinearGradient(-s * 0.5, -s * 0.3, s * 0.5, s * 0.3);
        bodyGrad.addColorStop(0, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',' + (0.7 + glowPulse * 0.2).toFixed(2) + ')');
        bodyGrad.addColorStop(0.6, 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.5)');
        bodyGrad.addColorStop(1, 'rgba(' + Math.round(col.r * 0.6) + ',' + Math.round(col.g * 0.6) + ',' + Math.round(col.b * 0.6) + ',0.4)');
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // Body highlight
        ctx.beginPath();
        ctx.ellipse(s * 0.15, -s * 0.12, s * 0.35, s * 0.1, -0.2, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fill();

        // Tail
        ctx.save();
        ctx.translate(-s * 0.5, 0);
        ctx.rotate(tailAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-s * 0.45, -s * 0.3);
        ctx.quadraticCurveTo(-s * 0.3, 0, -s * 0.45, s * 0.3);
        ctx.closePath();
        ctx.fillStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.35)';
        ctx.fill();
        // BC2 amber accent lines on tail
        ctx.beginPath();
        ctx.moveTo(-s * 0.05, -s * 0.02);
        ctx.lineTo(-s * 0.4, -s * 0.26);
        ctx.strokeStyle = 'rgba(247,147,26,0.4)';
        ctx.lineWidth = Math.max(0.5, s * 0.03);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-s * 0.05, s * 0.02);
        ctx.lineTo(-s * 0.4, s * 0.26);
        ctx.stroke();
        ctx.restore();

        // Eye
        var eyeX = s * 0.45;
        var eyeY = -s * 0.08;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, s * 0.09, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + s * 0.02, eyeY, s * 0.04, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.8)';
        ctx.fill();

        // Fin (dorsal)
        ctx.beginPath();
        ctx.moveTo(s * 0.1, -s * 0.3);
        ctx.quadraticCurveTo(s * 0.05, -s * 0.6, -s * 0.15, -s * 0.35);
        ctx.lineTo(-s * 0.05, -s * 0.25);
        ctx.closePath();
        ctx.fillStyle = 'rgba(' + col.r + ',' + col.g + ',' + col.b + ',0.25)';
        ctx.fill();
        // BC2 amber accent line on dorsal
        ctx.beginPath();
        ctx.moveTo(s * 0.08, -s * 0.32);
        ctx.quadraticCurveTo(s * 0.03, -s * 0.55, -s * 0.12, -s * 0.36);
        ctx.strokeStyle = 'rgba(247,147,26,0.35)';
        ctx.lineWidth = Math.max(0.5, s * 0.025);
        ctx.stroke();

        ctx.restore();
        ctx.globalAlpha = 1;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BUBBLE PARTICLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var bubbles = [];

    function spawnBubble(x, y, intensity) {
        var count = Math.floor(2 + intensity * 3);
        for (var i = 0; i < count; i++) {
            bubbles.push({
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 10,
                r: 1 + Math.random() * 3,
                vy: -(0.5 + Math.random() * 1.5) * intensity,
                vx: (Math.random() - 0.5) * 0.5,
                life: 1,
                decay: 0.005 + Math.random() * 0.01,
            });
        }
    }

    function updateBubbles() {
        for (var i = bubbles.length - 1; i >= 0; i--) {
            var b = bubbles[i];
            b.x += b.vx;
            b.y += b.vy;
            b.vy *= 0.99;
            b.life -= b.decay;
            if (b.life <= 0 || b.y < 0) {
                bubbles.splice(i, 1);
            }
        }
    }

    function drawBubbles() {
        for (var i = 0; i < bubbles.length; i++) {
            var b = bubbles[i];
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(56,189,248,' + (b.life * 0.3).toFixed(2) + ')';
            ctx.fill();
            ctx.strokeStyle = 'rgba(56,189,248,' + (b.life * 0.15).toFixed(2) + ')';
            ctx.lineWidth = 0.5;
            ctx.stroke();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  ENVIRONMENT ‚Äî ethereal background layers
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚îÄ‚îÄ God Rays (animated light shafts from surface) ‚îÄ‚îÄ
    var godRays = [];
    function generateGodRays() {
        godRays = [];
        var count = 5 + Math.floor(W / 250);
        for (var i = 0; i < count; i++) {
            godRays.push({
                x: Math.random() * W,
                width: 30 + Math.random() * 80,
                length: H * (0.35 + Math.random() * 0.4),
                angle: -0.08 + Math.random() * 0.16,
                alpha: 0.01 + Math.random() * 0.025,
                speed: 0.0003 + Math.random() * 0.0006,
                phase: Math.random() * Math.PI * 2,
                hue: Math.random() > 0.6 ? 'cyan' : 'gold',
            });
        }
    }
    generateGodRays();
    window.addEventListener('resize', generateGodRays);

    function drawGodRays(now) {
        for (var i = 0; i < godRays.length; i++) {
            var r = godRays[i];
            var pulse = 0.5 + Math.sin(now * r.speed + r.phase) * 0.5;
            var alpha = r.alpha * pulse;
            if (alpha < 0.002) continue;

            ctx.save();
            ctx.translate(r.x, 0);
            ctx.rotate(r.angle);

            var grad = ctx.createLinearGradient(0, 0, 0, r.length);
            if (r.hue === 'cyan') {
                grad.addColorStop(0, 'rgba(56,189,248,' + (alpha * 1.5).toFixed(4) + ')');
                grad.addColorStop(0.3, 'rgba(56,189,248,' + alpha.toFixed(4) + ')');
                grad.addColorStop(1, 'rgba(56,189,248,0)');
            } else {
                grad.addColorStop(0, 'rgba(247,200,100,' + (alpha * 1.2).toFixed(4) + ')');
                grad.addColorStop(0.3, 'rgba(247,180,80,' + (alpha * 0.7).toFixed(4) + ')');
                grad.addColorStop(1, 'rgba(247,147,26,0)');
            }

            ctx.fillStyle = grad;
            ctx.beginPath();
            var halfW = r.width * 0.5;
            var spreadW = halfW + r.length * 0.12;
            ctx.moveTo(-halfW, 0);
            ctx.lineTo(halfW, 0);
            ctx.lineTo(spreadW, r.length);
            ctx.lineTo(-spreadW, r.length);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
    }

    // ‚îÄ‚îÄ Bioluminescent Orbs (slow drifting background particles) ‚îÄ‚îÄ
    var orbs = [];
    function generateOrbs() {
        orbs = [];
        var count = 12 + Math.floor(W / 100);
        for (var i = 0; i < count; i++) {
            var hue = Math.random();
            var r, g, b;
            if (hue < 0.35) { r = 56; g = 189; b = 248; }       // cyan
            else if (hue < 0.6) { r = 74; g = 234; b = 188; }    // teal
            else if (hue < 0.8) { r = 120; g = 160; b = 220; }   // soft blue
            else { r = 200; g = 180; b = 140; }                    // warm mote
            orbs.push({
                x: Math.random() * W,
                y: Math.random() * H,
                r: 1.5 + Math.random() * 4,
                vx: (Math.random() - 0.5) * 0.08,
                vy: -0.02 - Math.random() * 0.06,
                cr: r, cg: g, cb: b,
                alpha: 0.1 + Math.random() * 0.25,
                phase: Math.random() * Math.PI * 2,
                pulseSpeed: 0.0008 + Math.random() * 0.002,
                glowR: 8 + Math.random() * 20,
            });
        }
    }
    generateOrbs();
    window.addEventListener('resize', generateOrbs);

    function drawOrbs(now) {
        for (var i = 0; i < orbs.length; i++) {
            var o = orbs[i];
            // Drift
            o.x += o.vx;
            o.y += o.vy;
            // Wrap
            if (o.y < -o.glowR) { o.y = H + o.glowR; o.x = Math.random() * W; }
            if (o.x < -o.glowR) o.x = W + o.glowR;
            if (o.x > W + o.glowR) o.x = -o.glowR;

            var pulse = 0.5 + Math.sin(now * o.pulseSpeed + o.phase) * 0.5;
            var a = o.alpha * pulse;

            // Outer glow
            var glow = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.glowR * (0.8 + pulse * 0.4));
            glow.addColorStop(0, 'rgba(' + o.cr + ',' + o.cg + ',' + o.cb + ',' + (a * 0.5).toFixed(3) + ')');
            glow.addColorStop(0.4, 'rgba(' + o.cr + ',' + o.cg + ',' + o.cb + ',' + (a * 0.15).toFixed(3) + ')');
            glow.addColorStop(1, 'rgba(' + o.cr + ',' + o.cg + ',' + o.cb + ',0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(o.x, o.y, o.glowR * (0.8 + pulse * 0.4), 0, Math.PI * 2);
            ctx.fill();

            // Core
            ctx.beginPath();
            ctx.arc(o.x, o.y, o.r * (0.7 + pulse * 0.3), 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + o.cr + ',' + o.cg + ',' + o.cb + ',' + (a * 1.2).toFixed(3) + ')';
            ctx.fill();
        }
    }

    // ‚îÄ‚îÄ Kelp / Seaweed ‚îÄ‚îÄ
    var kelps = [];
    function generateKelp() {
        kelps = [];
        var count = 6 + Math.floor(W / 180);
        for (var i = 0; i < count; i++) {
            var segments = 5 + Math.floor(Math.random() * 6);
            kelps.push({
                x: W * 0.05 + Math.random() * W * 0.9,
                segHeight: 12 + Math.random() * 18,
                segments: segments,
                width: 2 + Math.random() * 4,
                phase: Math.random() * Math.PI * 2,
                swaySpeed: 0.0006 + Math.random() * 0.001,
                swayAmount: 3 + Math.random() * 8,
                hue: Math.random() > 0.5 ? 'teal' : 'green',
                alpha: 0.06 + Math.random() * 0.1,
            });
        }
    }
    generateKelp();
    window.addEventListener('resize', generateKelp);

    function drawKelp(now) {
        for (var k = 0; k < kelps.length; k++) {
            var kp = kelps[k];
            var baseY = H - 8;
            var sway = Math.sin(now * kp.swaySpeed + kp.phase);

            ctx.beginPath();
            ctx.moveTo(kp.x, baseY);

            var px = kp.x;
            for (var s = 0; s < kp.segments; s++) {
                var progress = (s + 1) / kp.segments;
                var y = baseY - (s + 1) * kp.segHeight;
                var xOff = sway * kp.swayAmount * progress * progress;
                px = kp.x + xOff;
                ctx.lineTo(px, y);
            }

            var cr, cg, cb;
            if (kp.hue === 'teal') { cr = 40; cg = 140; cb = 120; }
            else { cr = 30; cg = 100; cb = 60; }

            ctx.strokeStyle = 'rgba(' + cr + ',' + cg + ',' + cb + ',' + kp.alpha.toFixed(3) + ')';
            ctx.lineWidth = kp.width;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            // Leaf tip glow
            var tipGlow = ctx.createRadialGradient(px, baseY - kp.segments * kp.segHeight, 0, px, baseY - kp.segments * kp.segHeight, 10);
            tipGlow.addColorStop(0, 'rgba(' + cr + ',' + (cg + 60) + ',' + cb + ',' + (kp.alpha * 0.5).toFixed(3) + ')');
            tipGlow.addColorStop(1, 'rgba(' + cr + ',' + cg + ',' + cb + ',0)');
            ctx.fillStyle = tipGlow;
            ctx.beginPath();
            ctx.arc(px, baseY - kp.segments * kp.segHeight, 10, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // ‚îÄ‚îÄ Seabed ‚îÄ‚îÄ
    var seabedPoints = [];
    function generateSeabed() {
        seabedPoints = [];
        var segments = Math.ceil(W / 15) + 2;
        for (var i = 0; i <= segments; i++) {
            var x = (i / segments) * W;
            var baseY = H - 14 + Math.sin(i * 0.35) * 6 + Math.sin(i * 0.12 + 2) * 10 + Math.sin(i * 0.8) * 2;
            seabedPoints.push({ x: x, y: baseY });
        }
    }
    generateSeabed();
    window.addEventListener('resize', generateSeabed);

    function drawSeabed(now) {
        if (!seabedPoints.length) return;

        // Seabed glow patches (bioluminescent spots on the floor)
        var patchCount = 4 + Math.floor(W / 300);
        for (var p = 0; p < patchCount; p++) {
            var px = W * (0.1 + (p / patchCount) * 0.8);
            var py = H - 6;
            var pulse = 0.4 + Math.sin(now * 0.0005 + p * 1.8) * 0.3;
            var glowGrad = ctx.createRadialGradient(px, py, 0, px, py, 40 + pulse * 20);
            glowGrad.addColorStop(0, 'rgba(74,234,188,' + (0.03 * pulse).toFixed(4) + ')');
            glowGrad.addColorStop(0.5, 'rgba(56,189,248,' + (0.015 * pulse).toFixed(4) + ')');
            glowGrad.addColorStop(1, 'rgba(56,189,248,0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(px, py, 40 + pulse * 20, 0, Math.PI * 2);
            ctx.fill();
        }

        // Sand fill
        ctx.beginPath();
        ctx.moveTo(0, H);
        for (var i = 0; i < seabedPoints.length; i++) {
            ctx.lineTo(seabedPoints[i].x, seabedPoints[i].y);
        }
        ctx.lineTo(W, H);
        ctx.closePath();

        var sandGrad = ctx.createLinearGradient(0, H - 25, 0, H);
        sandGrad.addColorStop(0, 'rgba(35,25,15,0.25)');
        sandGrad.addColorStop(0.5, 'rgba(28,20,12,0.4)');
        sandGrad.addColorStop(1, 'rgba(18,12,6,0.55)');
        ctx.fillStyle = sandGrad;
        ctx.fill();

        // Sand edge highlight
        ctx.beginPath();
        for (var i = 0; i < seabedPoints.length; i++) {
            if (i === 0) ctx.moveTo(seabedPoints[i].x, seabedPoints[i].y);
            else ctx.lineTo(seabedPoints[i].x, seabedPoints[i].y);
        }
        ctx.strokeStyle = 'rgba(74,234,188,0.04)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    // ‚îÄ‚îÄ Depth Fog ‚îÄ‚îÄ
    function drawDepthFog() {
        // Top surface light band
        var surfaceGrad = ctx.createLinearGradient(0, 0, 0, H * 0.15);
        surfaceGrad.addColorStop(0, 'rgba(20,40,65,0.12)');
        surfaceGrad.addColorStop(1, 'rgba(20,40,65,0)');
        ctx.fillStyle = surfaceGrad;
        ctx.fillRect(0, 0, W, H * 0.15);

        // Mid-depth haze
        var midGrad = ctx.createLinearGradient(0, H * 0.3, 0, H * 0.6);
        midGrad.addColorStop(0, 'rgba(4,14,26,0)');
        midGrad.addColorStop(0.5, 'rgba(6,18,32,0.06)');
        midGrad.addColorStop(1, 'rgba(4,14,26,0)');
        ctx.fillStyle = midGrad;
        ctx.fillRect(0, H * 0.3, W, H * 0.3);

        // Deep abyss at bottom
        var abyssGrad = ctx.createLinearGradient(0, H * 0.75, 0, H);
        abyssGrad.addColorStop(0, 'rgba(1,4,8,0)');
        abyssGrad.addColorStop(1, 'rgba(1,4,8,0.2)');
        ctx.fillStyle = abyssGrad;
        ctx.fillRect(0, H * 0.75, W, H * 0.25);
    }

    // ‚îÄ‚îÄ Water Surface Ripple ‚îÄ‚îÄ
    function drawSurface(now) {
        var t = now * 0.001;
        var surfaceY = 6;
        var amplitude = 3;
        var segments = Math.ceil(W / 8);

        // Refraction band ‚Äî lighter area above the wave
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        for (var i = 0; i <= segments; i++) {
            var x = (i / segments) * W;
            var y = surfaceY +
                Math.sin(x * 0.012 + t * 0.8) * amplitude +
                Math.sin(x * 0.025 - t * 1.1) * (amplitude * 0.5) +
                Math.sin(x * 0.006 + t * 0.4) * (amplitude * 1.5);
            ctx.lineTo(x, y);
        }
        ctx.lineTo(W, 0);
        ctx.closePath();
        var refrGrad = ctx.createLinearGradient(0, 0, 0, surfaceY + amplitude * 3);
        refrGrad.addColorStop(0, 'rgba(30,55,85,0.25)');
        refrGrad.addColorStop(0.5, 'rgba(56,189,248,0.06)');
        refrGrad.addColorStop(1, 'rgba(56,189,248,0)');
        ctx.fillStyle = refrGrad;
        ctx.fill();
        ctx.restore();

        // Main wave line
        ctx.beginPath();
        for (var i = 0; i <= segments; i++) {
            var x = (i / segments) * W;
            var y = surfaceY +
                Math.sin(x * 0.012 + t * 0.8) * amplitude +
                Math.sin(x * 0.025 - t * 1.1) * (amplitude * 0.5) +
                Math.sin(x * 0.006 + t * 0.4) * (amplitude * 1.5);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = 'rgba(56,189,248,0.12)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Second thinner wave slightly below
        ctx.beginPath();
        for (var i = 0; i <= segments; i++) {
            var x = (i / segments) * W;
            var y = surfaceY + 4 +
                Math.sin(x * 0.015 + t * 0.6 + 1.5) * (amplitude * 0.6) +
                Math.sin(x * 0.03 - t * 0.9 + 0.8) * (amplitude * 0.3);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.strokeStyle = 'rgba(56,189,248,0.05)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Highlight sparkles along the wave crest
        for (var i = 0; i < segments; i += 3) {
            var x = (i / segments) * W;
            var y = surfaceY +
                Math.sin(x * 0.012 + t * 0.8) * amplitude +
                Math.sin(x * 0.025 - t * 1.1) * (amplitude * 0.5) +
                Math.sin(x * 0.006 + t * 0.4) * (amplitude * 1.5);
            var sparkle = Math.sin(t * 2 + i * 0.7) * 0.5 + 0.5;
            if (sparkle > 0.85) {
                ctx.beginPath();
                ctx.arc(x, y, 1 + sparkle, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(180,220,255,' + ((sparkle - 0.85) * 4).toFixed(2) + ')';
                ctx.fill();
            }
        }
    }

    // ‚îÄ‚îÄ Surface wave height helper (reusable) ‚îÄ‚îÄ
    function getSurfaceY(x, t) {
        return 6 +
            Math.sin(x * 0.012 + t * 0.8) * 3 +
            Math.sin(x * 0.025 - t * 1.1) * 1.5 +
            Math.sin(x * 0.006 + t * 0.4) * 4.5;
    }
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BOAT ‚Äî drifts across surface occasionally
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var boat = null;
    var boatTimer = performance.now() + 45000 + Math.random() * 90000;

    function spawnBoat() {
        if (boat) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        var sz = 50 + Math.random() * 30;
        boat = {
            x: dir > 0 ? -sz * 1.5 : W + sz * 1.5,
            y: 0, dir: dir, size: sz,
            speed: 0.3 + Math.random() * 0.4,
            bobPhase: Math.random() * Math.PI * 2,
            tilt: 0, alpha: 0, wake: [],
            type: Math.random() < 0.6 ? 'sailboat' : 'fishing',
            mastHeight: 30 + Math.random() * 20,
            sailColor: Math.random() < 0.5 ? 'rgba(230,220,200,' : 'rgba(200,180,160,',
        };
        feedInfo('<span style="color:#94a3b8;">‚õµ A boat passes overhead‚Ä¶</span>');
    }

    function updateBoat(now, dt) {
        if (!boat && now > boatTimer) {
            spawnBoat();
            boatTimer = now + 90000 + Math.random() * 180000;
        }
        if (!boat) return;
        var b = boat;
        var t = now * 0.001;
        b.alpha = Math.min(1, b.alpha + 0.008 * dt);
        b.x += b.dir * b.speed * dt;
        b.bobPhase += 0.0012 * dt;
        var waveY = Math.sin(b.x * 0.012 + t * 0.8) * 3 + Math.sin(b.x * 0.006 + t * 0.4) * 4.5;
        b.y = 4 + waveY * 0.4 + Math.sin(b.bobPhase) * 1;
        var waveYN = Math.sin((b.x + 5) * 0.012 + t * 0.8) * 3 + Math.sin((b.x + 5) * 0.006 + t * 0.4) * 4.5;
        b.tilt += ((waveYN - waveY) * 0.03 - b.tilt) * 0.04 * dt;
        if (Math.random() < 0.15) {
            b.wake.push({ x: b.x - b.dir * b.size * 0.5, y: b.y + 6,
                vx: -b.dir * (0.2 + Math.random() * 0.3), size: 1 + Math.random() * 2, life: 1 });
        }
        for (var i = b.wake.length - 1; i >= 0; i--) {
            b.wake[i].x += b.wake[i].vx * dt;
            b.wake[i].life -= 0.008 * dt;
            b.wake[i].size += 0.01 * dt;
            if (b.wake[i].life <= 0) b.wake.splice(i, 1);
        }
        if ((b.dir > 0 && b.x > W + b.size * 2) || (b.dir < 0 && b.x < -b.size * 2)) {
            boat = null; return;
        }
        // Push nearby fish down (boat shadow spooks them)
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            if (Math.abs(f.x - b.x) < b.size && f.y < 35) {
                f.vy += 0.03 * dt;
            }
        }
    }

    function drawBoat(now) {
        if (!boat || boat.alpha < 0.01) return;
        var b = boat;
        var t = now * 0.001;
        var s = b.size;
        ctx.save();
        ctx.translate(b.x, b.y);
        ctx.rotate(b.tilt);
        ctx.globalAlpha = b.alpha;
        // Wake
        for (var i = 0; i < b.wake.length; i++) {
            var w = b.wake[i];
            ctx.beginPath();
            ctx.arc(w.x - b.x, w.y - b.y + 4, w.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(180,210,230,' + (w.life * 0.12).toFixed(3) + ')';
            ctx.fill();
        }
        // Shadow
        ctx.beginPath();
        ctx.ellipse(0, 12, s * 0.5, 4, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; ctx.fill();

        if (b.type === 'sailboat') {
            // Hull
            ctx.beginPath();
            ctx.moveTo(-s * 0.5, 0);
            ctx.quadraticCurveTo(-s * 0.45, 5, -s * 0.15, 6);
            ctx.lineTo(s * 0.25, 6);
            ctx.quadraticCurveTo(s * 0.5, 5, s * 0.55, 0);
            ctx.quadraticCurveTo(s * 0.3, 2, 0, 2);
            ctx.quadraticCurveTo(-s * 0.3, 2, -s * 0.5, 0);
            var hg = ctx.createLinearGradient(0, -1, 0, 6);
            hg.addColorStop(0, 'rgba(60,50,40,0.7)');
            hg.addColorStop(1, 'rgba(40,35,28,0.6)');
            ctx.fillStyle = hg; ctx.fill();
            // Stripe
            ctx.beginPath();
            ctx.moveTo(-s * 0.43, 2);
            ctx.quadraticCurveTo(0, 3.5, s * 0.48, 2);
            ctx.strokeStyle = 'rgba(180,60,40,0.3)'; ctx.lineWidth = 1; ctx.stroke();
            // Mast
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -b.mastHeight);
            ctx.strokeStyle = 'rgba(80,65,50,0.6)'; ctx.lineWidth = 1.5; ctx.stroke();
            // Sail
            var billow = Math.sin(t * 0.5 + b.bobPhase) * 3 * b.dir;
            ctx.beginPath();
            ctx.moveTo(0, -b.mastHeight + 2);
            ctx.quadraticCurveTo(billow + b.dir * 8, -b.mastHeight * 0.5, 0, -2);
            ctx.lineTo(0, -b.mastHeight + 2);
            ctx.fillStyle = b.sailColor + '0.4)'; ctx.fill();
            ctx.strokeStyle = b.sailColor + '0.2)'; ctx.lineWidth = 0.5; ctx.stroke();
            // Pennant
            ctx.beginPath();
            ctx.moveTo(0, -b.mastHeight);
            ctx.lineTo(b.dir * 6 + Math.sin(t * 2) * 2, -b.mastHeight - 2);
            ctx.lineTo(0, -b.mastHeight + 2);
            ctx.fillStyle = 'rgba(200,60,50,0.35)'; ctx.fill();
        } else {
            // Fishing boat
            ctx.beginPath();
            ctx.moveTo(-s * 0.45, -1); ctx.lineTo(-s * 0.5, 4);
            ctx.quadraticCurveTo(-s * 0.3, 7, 0, 7);
            ctx.quadraticCurveTo(s * 0.35, 7, s * 0.45, 3);
            ctx.lineTo(s * 0.4, -1); ctx.closePath();
            var hg = ctx.createLinearGradient(0, -2, 0, 7);
            hg.addColorStop(0, 'rgba(50,70,90,0.65)');
            hg.addColorStop(1, 'rgba(35,50,65,0.55)');
            ctx.fillStyle = hg; ctx.fill();
            // Cabin
            ctx.fillStyle = 'rgba(70,60,50,0.5)';
            ctx.fillRect(-s * 0.1, -8, s * 0.2, 7);
            ctx.fillStyle = 'rgba(90,80,65,0.4)';
            ctx.fillRect(-s * 0.13, -9, s * 0.26, 2);
            // Fishing rod
            var rodTip = Math.sin(t * 0.7 + b.bobPhase) * 4;
            ctx.beginPath();
            ctx.moveTo(s * 0.2, -4);
            ctx.quadraticCurveTo(s * 0.35, -20, s * 0.15 + rodTip, -25);
            ctx.strokeStyle = 'rgba(100,80,60,0.4)'; ctx.lineWidth = 0.8; ctx.stroke();
            // Line
            ctx.beginPath();
            ctx.moveTo(s * 0.15 + rodTip, -25);
            ctx.lineTo(s * 0.12 + rodTip * 0.5, 15 + Math.sin(t) * 2);
            ctx.strokeStyle = 'rgba(150,150,150,0.15)'; ctx.lineWidth = 0.3; ctx.stroke();
        }
        ctx.restore();
    }


    // ‚îÄ‚îÄ Sediment Particles (whale seabed kick) ‚îÄ‚îÄ
    var sediments = [];

    function spawnSediment(x) {
        var count = 8 + Math.floor(Math.random() * 8);
        for (var i = 0; i < count; i++) {
            sediments.push({
                x: x + (Math.random() - 0.5) * 60,
                y: H - 12 - Math.random() * 8,
                r: 0.8 + Math.random() * 2,
                vx: (Math.random() - 0.5) * 1.2,
                vy: -(0.4 + Math.random() * 1.8),
                life: 1,
                decay: 0.004 + Math.random() * 0.008,
                cr: 140 + Math.floor(Math.random() * 60),
                cg: 110 + Math.floor(Math.random() * 40),
                cb: 70 + Math.floor(Math.random() * 30),
            });
        }
    }

    function updateSediments() {
        for (var i = sediments.length - 1; i >= 0; i--) {
            var s = sediments[i];
            s.x += s.vx;
            s.y += s.vy;
            s.vy += 0.008; // gentle gravity
            s.vx *= 0.995;
            s.life -= s.decay;
            if (s.life <= 0 || s.y > H + 5) {
                sediments.splice(i, 1);
            }
        }
    }

    function drawSediments() {
        for (var i = 0; i < sediments.length; i++) {
            var s = sediments[i];
            var a = s.life * 0.35;
            // Glow
            var glow = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.r * 3);
            glow.addColorStop(0, 'rgba(' + s.cr + ',' + s.cg + ',' + s.cb + ',' + (a * 0.3).toFixed(3) + ')');
            glow.addColorStop(1, 'rgba(' + s.cr + ',' + s.cg + ',' + s.cb + ',0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r * 3, 0, Math.PI * 2);
            ctx.fill();
            // Core
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + s.cr + ',' + s.cg + ',' + s.cb + ',' + a.toFixed(3) + ')';
            ctx.fill();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  AMBIENT EVENTS ‚Äî ocean comes alive
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚îÄ‚îÄ 1) PREDATOR CHASE ‚Äî big dark fish chases a small one, gives up ‚îÄ‚îÄ
    var predator = null;

    function spawnPredatorChase() {
        // Count active (non-scooped, alive) fish ‚Äî not raw array length
        var activeFishCount = 0;
        for (var fi = 0; fi < fishes.length; fi++) {
            if (fishes[fi].alive && !fishes[fi].scooped && !fishes[fi].rbfEaten) activeFishCount++;
        }
        if (predator || whale || activeFishCount < 5) return;

        var enterSide = Math.random() > 0.5 ? 1 : -1;
        predator = {
            x: enterSide > 0 ? -60 : W + 60,
            y: H * 0.2 + Math.random() * H * 0.5,
            vx: 0, vy: 0,
            dir: enterSide > 0 ? 1 : -1,
            size: 28 + Math.random() * 12,
            prey: null,
            phase: 0, // 0=entering, 1=chasing, 2=switching, 3=tiring, 4=fleeing
            startTime: performance.now(),
            chaseDuration: 2000 + Math.random() * 1500, // per-target
            tailPhase: Math.random() * Math.PI * 2,
            tailSpeed: 8,
            glowPhase: Math.random() * Math.PI * 2,
            alpha: 0,
            tilt: 0,
            targetsChased: 0,
            maxTargets: 2 + Math.floor(Math.random() * 3), // 2-4 targets
            _chaseStart: 0,
        };

        pickPredatorTarget(predator);
        feedInfo('<span style="color:#94a3b8;">ü¶à A shadow enters the tank‚Ä¶</span>');
    }

    function pickPredatorTarget(p) {
        // Release old prey
        if (p.prey && p.prey.alive) {
            p.prey._scared = false;
            p.prey.tailSpeed = p.prey.baseTailSpeed || (3 + Math.abs(p.prey.vx) * 2);
        }

        // Find small fish, preferring ones nearby
        var candidates = fishes.filter(function(f) {
            return f.alive && !f.scooped && !f.rbfEaten && !f.rbfHunted && !f.isRbf && f.size < 18
                && f !== p.prey; // don't re-pick same fish
        });
        if (!candidates.length) { p.prey = null; return; }

        // Sort by distance, pick from closest third with some randomness
        candidates.sort(function(a, b) {
            var da = (a.x - p.x) * (a.x - p.x) + (a.y - p.y) * (a.y - p.y);
            var db = (b.x - p.x) * (b.x - p.x) + (b.y - p.y) * (b.y - p.y);
            return da - db;
        });
        var pool = candidates.slice(0, Math.max(3, Math.ceil(candidates.length * 0.3)));
        var prey = pool[Math.floor(Math.random() * pool.length)];

        p.prey = prey;
        prey._scared = true;
        prey._scareTime = performance.now();
        p._chaseStart = performance.now();
    }

    function updatePredatorChase(now, dt) {
        if (!predator) return;
        var p = predator;
        var elapsed = now - p.startTime;
        p.tailPhase += p.tailSpeed * 0.025 * dt;
        p.glowPhase += 0.02 * dt;

        var prey = p.prey;

        if (p.phase === 0) {
            // Entering ‚Äî fade in and approach first target
            p.alpha = Math.min(1, elapsed / 600);
            if (prey && prey.alive && !prey.scooped) {
                var dx = prey.x - p.x;
                var dy = prey.y - p.y;
                var dist = Math.sqrt(dx * dx + dy * dy) || 1;
                p.vx += (dx / dist) * 0.08 * dt;
                p.vy += (dy / dist) * 0.04 * dt;
                if (dist < 200 || elapsed > 1500) p.phase = 1;
            } else {
                p.phase = 1;
                pickPredatorTarget(p);
            }
        }

        if (p.phase === 1) {
            // Active chase
            var chaseElapsed = now - p._chaseStart;

            if (!prey || !prey.alive || prey.scooped) {
                // Target gone ‚Äî pick new one or leave
                p.phase = 2;
                p._switchStart = now;
            } else {
                var dx = prey.x - p.x;
                var dy = prey.y - p.y;
                var dist = Math.sqrt(dx * dx + dy * dy) || 1;
                var aggression = 0.12 - chaseElapsed * 0.00002;
                p.vx += (dx / dist) * Math.max(aggression, 0.04) * dt;
                p.vy += (dy / dist) * Math.max(aggression * 0.6, 0.02) * dt;
                p.tailSpeed = 10 + (1 - dist / W) * 5;

                // Make prey dodge
                var fleeX = prey.x - p.x;
                var fleeY = prey.y - p.y;
                var fleeDist = Math.sqrt(fleeX * fleeX + fleeY * fleeY) || 1;
                prey.vx += (fleeX / fleeDist) * 0.15 * dt;
                prey.vy += (fleeY / fleeDist) * 0.08 * dt;
                if (Math.random() < 0.05) {
                    prey.vy += (Math.random() - 0.5) * 3;
                    spawnBubble(prey.x, prey.y, 0.8);
                }
                prey.tailSpeed = 12;

                // Bubble trail
                if (Math.random() < 0.06) spawnBubble(p.x - p.dir * p.size * 0.4, p.y, 0.6);

                // Time to switch targets?
                if (chaseElapsed > p.chaseDuration) {
                    p.phase = 2;
                    p._switchStart = now;
                    p.targetsChased++;
                }
            }
        }

        if (p.phase === 2) {
            // Brief pause between targets ‚Äî circle/weave menacingly
            var switchElapsed = now - p._switchStart;
            p.vx *= 0.96;
            p.vy += Math.sin(now * 0.004) * 0.04 * dt;
            p.tailSpeed = Math.max(5, p.tailSpeed - 0.03 * dt);

            // Release current prey
            if (prey && prey.alive) {
                prey._scared = false;
                prey.tailSpeed = prey.baseTailSpeed || (3 + Math.abs(prey.vx) * 2);
            }

            if (switchElapsed > 800 + Math.random() * 600) {
                if (p.targetsChased >= p.maxTargets) {
                    // Done hunting
                    p.phase = 3;
                    feedInfo('<span style="color:#94a3b8;">ü¶à The predator loses interest and retreats‚Ä¶</span>');
                } else {
                    // Pick next target
                    pickPredatorTarget(p);
                    if (p.prey) {
                        p.phase = 1;
                        p.chaseDuration = 1500 + Math.random() * 2000; // each chase gets shorter
                        feedInfo('<span style="color:#94a3b8;">ü¶à The predator spots another target!</span>');
                    } else {
                        p.phase = 3;
                        feedInfo('<span style="color:#94a3b8;">ü¶à The predator retreats‚Ä¶</span>');
                    }
                }
            }
        }

        if (p.phase === 3) {
            // Tiring ‚Äî slowing down
            p.vx *= 0.97;
            p.vy *= 0.97;
            p.vy += Math.sin(now * 0.003) * 0.03 * dt;
            p.tailSpeed = Math.max(4, p.tailSpeed - 0.05 * dt);

            var tireStart = p._switchStart || p._chaseStart;
            if (now - tireStart > 1500) {
                p.phase = 4;
            }
        }

        if (p.phase === 4) {
            // Fleeing ‚Äî exit
            var exitX = p.dir > 0 ? W + 100 : -100;
            p.vx += (exitX - p.x) * 0.002 * dt;
            p.vy *= 0.95;
            p.alpha -= 0.008 * dt;
            if (p.alpha <= 0 || p.x < -120 || p.x > W + 120) {
                if (p.prey && p.prey.alive) {
                    p.prey._scared = false;
                    p.prey.tailSpeed = p.prey.baseTailSpeed || 4;
                }
                predator = null;
                return;
            }
        }

        // Apply velocity
        p.vx = Math.max(-5, Math.min(5, p.vx));
        p.vy = Math.max(-3, Math.min(3, p.vy));
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.y = Math.max(p.size, Math.min(H - 30 - p.size, p.y));
        p.dir = p.vx > 0 ? 1 : -1;
        // Smooth tilt
        var predTilt = Math.atan2(p.vy, Math.abs(p.vx) + 0.5);
        predTilt = Math.max(-0.6, Math.min(0.6, predTilt));
        p.tilt = (p.tilt || 0) + (predTilt - (p.tilt || 0)) * 0.08 * dt;
    }

    function drawPredator(now) {
        if (!predator) return;
        var p = predator;
        var s = p.size;
        ctx.save();
        ctx.globalAlpha = Math.max(0, p.alpha);
        ctx.translate(p.x, p.y);
        if (p.dir < 0) ctx.scale(-1, 1);
        ctx.rotate(p.tilt || 0);

        var tailAngle = Math.sin(p.tailPhase) * 0.35;

        // Dark menacing glow
        var glowPulse = 0.5 + Math.sin(p.glowPhase) * 0.3;
        var glow = ctx.createRadialGradient(0, 0, s * 0.3, 0, 0, s * 2.5);
        glow.addColorStop(0, 'rgba(40,20,30,' + (0.2 * glowPulse).toFixed(3) + ')');
        glow.addColorStop(0.5, 'rgba(80,30,30,' + (0.06 * glowPulse).toFixed(3) + ')');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, s * 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Body ‚Äî darker, more angular
        ctx.beginPath();
        ctx.moveTo(s * 1.1, 0);
        ctx.bezierCurveTo(s * 0.8, -s * 0.5, -s * 0.2, -s * 0.5, -s * 0.6, -s * 0.15);
        ctx.bezierCurveTo(-s * 0.7, 0, -s * 0.7, 0, -s * 0.6, s * 0.15);
        ctx.bezierCurveTo(-s * 0.2, s * 0.5, s * 0.8, s * 0.5, s * 1.1, 0);
        ctx.closePath();
        var bodyGrad = ctx.createLinearGradient(0, -s * 0.4, 0, s * 0.4);
        bodyGrad.addColorStop(0, 'rgba(50,30,40,0.85)');
        bodyGrad.addColorStop(0.5, 'rgba(35,20,25,0.9)');
        bodyGrad.addColorStop(1, 'rgba(25,15,20,0.8)');
        ctx.fillStyle = bodyGrad;
        ctx.fill();

        // Tail
        ctx.save();
        ctx.translate(-s * 0.6, 0);
        ctx.rotate(tailAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-s * 0.55, -s * 0.35);
        ctx.quadraticCurveTo(-s * 0.35, 0, -s * 0.55, s * 0.35);
        ctx.closePath();
        ctx.fillStyle = 'rgba(40,20,25,0.6)';
        ctx.fill();
        // Amber accent on tail
        ctx.beginPath();
        ctx.moveTo(-s * 0.05, -s * 0.02);
        ctx.lineTo(-s * 0.48, -s * 0.3);
        ctx.strokeStyle = 'rgba(200,60,40,0.3)';
        ctx.lineWidth = Math.max(0.8, s * 0.035);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-s * 0.05, s * 0.02);
        ctx.lineTo(-s * 0.48, s * 0.3);
        ctx.stroke();
        ctx.restore();

        // Dorsal fin ‚Äî sharp
        ctx.beginPath();
        ctx.moveTo(s * 0.15, -s * 0.4);
        ctx.lineTo(s * 0.05, -s * 0.8);
        ctx.lineTo(-s * 0.15, -s * 0.42);
        ctx.closePath();
        ctx.fillStyle = 'rgba(40,20,25,0.5)';
        ctx.fill();

        // Eye ‚Äî angry red glint
        var eyeX = s * 0.6;
        var eyeY = -s * 0.1;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, s * 0.1, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(eyeX + s * 0.02, eyeY, s * 0.055, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180,30,30,0.9)';
        ctx.fill();
        // Eye glow
        var eyeGlow = ctx.createRadialGradient(eyeX, eyeY, 0, eyeX, eyeY, s * 0.3);
        eyeGlow.addColorStop(0, 'rgba(200,50,30,0.15)');
        eyeGlow.addColorStop(1, 'rgba(200,50,30,0)');
        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, s * 0.3, 0, Math.PI * 2);
        ctx.fill();

        // Mouth line ‚Äî subtle snarl
        ctx.beginPath();
        ctx.moveTo(s * 1.08, -s * 0.03);
        ctx.quadraticCurveTo(s * 0.9, 0, s * 1.08, s * 0.03);
        ctx.strokeStyle = 'rgba(200,60,40,0.4)';
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }

    // ‚îÄ‚îÄ 2) BUBBLE VENT ‚Äî thermal geyser from seabed ‚îÄ‚îÄ
    var ventActive = false;
    var activeVent = null; // {x, y, strength} for fish push

    function triggerBubbleVent() {
        if (ventActive) return;
        ventActive = true;
        var ventX = W * 0.15 + Math.random() * W * 0.7;
        var ventY = H - 15;
        var burstCount = 0;
        var maxBursts = 15 + Math.floor(Math.random() * 20);

        // Expose vent position for fish updraft
        activeVent = { x: ventX, y: ventY, strength: 0.5 + Math.random() * 0.5 };

        function burst() {
            if (burstCount >= maxBursts) {
                ventActive = false;
                activeVent = null;
                return;
            }
            var count = 3 + Math.floor(Math.random() * 4);
            for (var i = 0; i < count; i++) {
                bubbles.push({
                    x: ventX + (Math.random() - 0.5) * 30,
                    y: ventY + Math.random() * 5,
                    r: 1.5 + Math.random() * 4,
                    vy: -(1.5 + Math.random() * 3),
                    vx: (Math.random() - 0.5) * 0.8,
                    life: 1,
                    decay: 0.003 + Math.random() * 0.005,
                });
            }
            // Sediment kick
            if (burstCount < 5) spawnSediment(ventX);
            burstCount++;
            setTimeout(burst, 60 + Math.random() * 120);
        }
        burst();
        feedInfo('<span style="color:#38bdf8;">ü´ß Thermal vent erupts from the seabed</span>');
    }

    // ‚îÄ‚îÄ 3) BIOLUMINESCENT PULSE ‚Äî wave of light across tank ‚îÄ‚îÄ
    var biolumPulse = null;

    function triggerBiolumPulse() {
        if (biolumPulse) return;
        biolumPulse = {
            startTime: performance.now(),
            originX: Math.random() * W,
            duration: 3000,
            speed: W * 0.0008,
        };
    }

    function updateBiolumPulse(now) {
        if (!biolumPulse) return;
        var elapsed = now - biolumPulse.startTime;
        if (elapsed > biolumPulse.duration) { biolumPulse = null; return; }

        var waveRadius = elapsed * biolumPulse.speed;
        var fadeIn = Math.min(1, elapsed / 400);
        var fadeOut = Math.max(0, 1 - (elapsed - biolumPulse.duration * 0.6) / (biolumPulse.duration * 0.4));
        var intensity = fadeIn * fadeOut;

        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            var dx = f.x - biolumPulse.originX;
            var fishDist = Math.abs(dx);
            var waveDist = Math.abs(fishDist - waveRadius);
            if (waveDist < 80) {
                var boost = (1 - waveDist / 80) * intensity * 0.6;
                f.glowPhase += boost * 0.1; // spin glow faster
                f._biolumBoost = boost;
            } else {
                f._biolumBoost = (f._biolumBoost || 0) * 0.95;
            }
        }
    }

    function drawBiolumWave(now) {
        if (!biolumPulse) return;
        var elapsed = now - biolumPulse.startTime;
        var waveRadius = elapsed * biolumPulse.speed;
        var fadeIn = Math.min(1, elapsed / 400);
        var fadeOut = Math.max(0, 1 - (elapsed - biolumPulse.duration * 0.6) / (biolumPulse.duration * 0.4));
        var alpha = fadeIn * fadeOut * 0.04;
        if (alpha < 0.001) return;

        // Draw expanding ring of light
        ctx.beginPath();
        ctx.arc(biolumPulse.originX, H * 0.5, waveRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(74,234,188,' + alpha.toFixed(4) + ')';
        ctx.lineWidth = 60;
        ctx.stroke();
    }

    // ‚îÄ‚îÄ 4) SCHOOLING ‚Äî fish cluster together briefly ‚îÄ‚îÄ
    var schoolEvent = null;

    function triggerSchooling() {
        if (schoolEvent || fishes.length < 8) return;
        // Pick a cluster of nearby fish
        var center = fishes[Math.floor(Math.random() * fishes.length)];
        if (!center || center.scooped || center.rbfEaten || center.isRbf) return;

        var nearby = fishes.filter(function(f) {
            if (f === center || f.scooped || f.rbfEaten || f.isRbf || f._scared) return false;
            var dx = f.x - center.x;
            var dy = f.y - center.y;
            return Math.sqrt(dx * dx + dy * dy) < 200;
        }).slice(0, 8);

        if (nearby.length < 3) return;

        schoolEvent = {
            fish: nearby,
            centerFish: center,
            startTime: performance.now(),
            duration: 4000 + Math.random() * 3000,
            targetX: center.x + center.dir * 250,
            targetY: center.y + (Math.random() - 0.5) * 100,
        };

        // Set school direction
        var schoolDir = center.dir;
        nearby.forEach(function(f) {
            f._schooling = true;
            f._schoolDir = schoolDir;
        });
        center._schooling = true;
        center._schoolDir = schoolDir;
    }

    function updateSchooling(now, dt) {
        if (!schoolEvent) return;
        var elapsed = now - schoolEvent.startTime;

        if (elapsed > schoolEvent.duration) {
            // Release school
            schoolEvent.fish.forEach(function(f) { f._schooling = false; });
            schoolEvent.centerFish._schooling = false;
            schoolEvent = null;
            return;
        }

        var center = schoolEvent.centerFish;
        var progress = elapsed / schoolEvent.duration;
        var cohesion = progress < 0.3 ? progress / 0.3 : (progress > 0.7 ? (1 - progress) / 0.3 : 1);

        schoolEvent.fish.forEach(function(f, idx) {
            if (!f.alive || f.scooped) return;
            // Formation offset ‚Äî stagger
            var offsetX = (idx % 3 - 1) * f.size * 1.8;
            var offsetY = (Math.floor(idx / 3) - 1) * f.size * 2;
            var targetX = center.x + offsetX;
            var targetY = center.y + offsetY;

            // Gentle steering toward formation
            var dx = targetX - f.x;
            var dy = targetY - f.y;
            var dist = Math.sqrt(dx * dx + dy * dy) || 1;

            // Very gentle force ‚Äî fish glide into formation
            var force = Math.min(0.008, dist * 0.00015) * cohesion;
            f.vx += (dx / dist) * force * dt;
            f.vy += (dy / dist) * force * dt;

            // Match leader speed gently
            f.vx += (center.vx - f.vx) * 0.02 * cohesion * dt;

            f.dir = center.dir;
            f.tailSpeed = 3.5 + cohesion * 1.5;
        });
    }

    // ‚îÄ‚îÄ 5) CURRENT SWEEP ‚Äî visible current pushes fish ‚îÄ‚îÄ
    var currentSweep = null;

    function triggerCurrentSweep() {
        if (currentSweep) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        currentSweep = {
            dir: dir,
            startTime: performance.now(),
            duration: 3000 + Math.random() * 2000,
            strength: 0.4 + Math.random() * 0.6,
            yBand: H * 0.2 + Math.random() * H * 0.5,
            yWidth: H * 0.2 + Math.random() * H * 0.2,
            particles: [],
        };

        // Spawn current streak particles
        for (var i = 0; i < 12; i++) {
            currentSweep.particles.push({
                x: dir > 0 ? -Math.random() * W * 0.3 : W + Math.random() * W * 0.3,
                y: currentSweep.yBand + (Math.random() - 0.5) * currentSweep.yWidth,
                len: 30 + Math.random() * 60,
                speed: (1.5 + Math.random() * 2) * dir,
                alpha: 0.02 + Math.random() * 0.04,
                delay: Math.random() * 800,
            });
        }

        feedInfo('<span style="color:#38bdf8;">üåä Ocean current sweeps through‚Ä¶</span>');
    }

    function updateCurrentSweep(now, dt) {
        if (!currentSweep) return;
        var elapsed = now - currentSweep.startTime;
        if (elapsed > currentSweep.duration) { currentSweep = null; return; }

        var fadeIn = Math.min(1, elapsed / 500);
        var fadeOut = Math.max(0, 1 - (elapsed - currentSweep.duration * 0.7) / (currentSweep.duration * 0.3));
        var intensity = fadeIn * fadeOut * currentSweep.strength;

        // Push fish in current band
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            var yDist = Math.abs(f.y - currentSweep.yBand);
            if (yDist < currentSweep.yWidth) {
                var falloff = 1 - yDist / currentSweep.yWidth;
                f.vx += currentSweep.dir * intensity * falloff * 0.02 * dt;
            }
        }

        // Move streak particles
        for (var j = 0; j < currentSweep.particles.length; j++) {
            var p = currentSweep.particles[j];
            if (elapsed < p.delay) continue;
            p.x += p.speed * dt;
        }
    }

    function drawCurrentSweep(now) {
        if (!currentSweep) return;
        var elapsed = now - currentSweep.startTime;
        var fadeIn = Math.min(1, elapsed / 500);
        var fadeOut = Math.max(0, 1 - (elapsed - currentSweep.duration * 0.7) / (currentSweep.duration * 0.3));
        var alpha = fadeIn * fadeOut;
        if (alpha < 0.005) return;

        for (var j = 0; j < currentSweep.particles.length; j++) {
            var p = currentSweep.particles[j];
            if (elapsed < p.delay) continue;
            if (p.x < -100 || p.x > W + 100) continue;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p.x + p.len * currentSweep.dir, p.y + (Math.random() - 0.5) * 2);
            ctx.strokeStyle = 'rgba(56,189,248,' + (p.alpha * alpha).toFixed(4) + ')';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // ‚îÄ‚îÄ EVENT SCHEDULER ‚îÄ‚îÄ
    var eventTimers = {
        // ‚îÄ‚îÄ COMMON (30-90s) ‚îÄ‚îÄ
        bubbleVent:    { interval: 35000, variance: 20000, lastFired: 0 },
        schooling:     { interval: 45000, variance: 25000, lastFired: 0 },
        biolumPulse:   { interval: 55000, variance: 30000, lastFired: 0 },
        jellyfish:     { interval: 65000, variance: 35000, lastFired: 0 },
        predatorChase: { interval: 75000, variance: 35000, lastFired: 0 },
        currentSweep:  { interval: 90000, variance: 45000, lastFired: 0 },
        // ‚îÄ‚îÄ UNCOMMON (2-5 min) ‚îÄ‚îÄ
        baitball:      { interval: 120000, variance: 70000, lastFired: 0 },
        hermitCrab:    { interval: 140000, variance: 90000, lastFired: 0 },
        treasureDrop:  { interval: 160000, variance: 100000, lastFired: 0 },
        tideChange:    { interval: 180000, variance: 120000, lastFired: 0 },
        planktonBloom: { interval: 200000, variance: 120000, lastFired: 0 },
        electricEel:   { interval: 220000, variance: 140000, lastFired: 0 },
        anglerfish:    { interval: 250000, variance: 150000, lastFired: 0 },
        seaTurtle:     { interval: 180000, variance: 120000, lastFired: 0 },
        // ‚îÄ‚îÄ RARE (6-12 min) ‚îÄ‚îÄ
        seaquake:      { interval: 350000, variance: 200000, lastFired: 0 },
        mantaRay:      { interval: 400000, variance: 250000, lastFired: 0 },
        aurora:        { interval: 450000, variance: 280000, lastFired: 0 },
        lightningStrike:{ interval: 550000, variance: 300000, lastFired: 0 },
        krakenTentacle:{ interval: 700000, variance: 400000, lastFired: 0 },
        // ‚îÄ‚îÄ ULTRA RARE (20-40+ min) ‚îÄ‚îÄ
        bottleMessage: { interval: 1200000, variance: 800000, lastFired: 0 },
        satoshiGhost:  { interval: 2400000, variance: 1500000, lastFired: 0 },
    };

    function scheduleNextFire(name) {
        var e = eventTimers[name];
        e.lastFired = performance.now();
        e.nextFire = e.lastFired + e.interval + (Math.random() - 0.5) * 2 * e.variance;
    }
    // Initialize with staggered starts ‚Äî cap delay so rare creatures don't wait forever
    Object.keys(eventTimers).forEach(function(name, idx) {
        var baseDelay = 5000 + idx * 4000 + Math.random() * 8000;
        // Cap initial delay: common at ~30s, uncommon at ~60s, rare at ~90s
        var maxInitial = eventTimers[name].interval * 0.5;
        eventTimers[name].nextFire = performance.now() + Math.min(baseDelay, maxInitial);
    });

    // ‚îÄ‚îÄ 6) ANGLERFISH ‚Äî deep-sea lure from the abyss ‚îÄ‚îÄ
    var anglerfish = null;

    function spawnAnglerfish() {
        if (anglerfish) return;
        var enterSide = Math.random() > 0.5 ? 1 : -1;
        anglerfish = {
            x: enterSide > 0 ? -80 : W + 80,
            y: H * 0.7 + Math.random() * H * 0.15,
            dir: enterSide,
            size: 35 + Math.random() * 15,
            phase: 0, // 0=drift in, 1=lure, 2=snap, 3=exit
            startTime: performance.now(),
            lureDuration: 3000 + Math.random() * 3000,
            tailPhase: Math.random() * Math.PI * 2,
            glowPhase: Math.random() * Math.PI * 2,
            lureY: 0,
            luredFish: [],
            alpha: 0,
            jawOpen: 0,
        };
        feedInfo('<span style="color:#a78bfa;">ü™º Something glows in the deep‚Ä¶</span>');
    }

    function updateAnglerfish(now, dt) {
        if (!anglerfish) return;
        var a = anglerfish;
        var elapsed = now - a.startTime;
        a.tailPhase += 3 * 0.02 * dt;
        a.glowPhase += 0.03 * dt;

        if (a.phase === 0) {
            a.alpha = Math.min(0.85, elapsed / 1500);
            a.x += a.dir * 0.6 * dt;
            a.y += Math.sin(now * 0.001) * 0.15 * dt;
            if (elapsed > 2500) { a.phase = 1; a._lureStart = now; }
        }

        if (a.phase === 1) {
            // Dangling lure above head ‚Äî bioluminescent bait
            a.lureY = -a.size * 1.3 + Math.sin(now * 0.004) * 8;
            var lureWorldX = a.x + a.dir * a.size * 0.3;
            var lureWorldY = a.y + a.lureY;

            // Attract nearby small fish toward lure
            for (var i = 0; i < fishes.length; i++) {
                var f = fishes[i];
                if (f.scooped || f.rbfEaten || f.isRbf || f.size > 14 || f._scared) continue;
                var dx = lureWorldX - f.x;
                var dy = lureWorldY - f.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 150 && dist > 10) {
                    f.vx += (dx / dist) * 0.03 * dt;
                    f.vy += (dy / dist) * 0.02 * dt;
                    if (a.luredFish.indexOf(f) === -1) a.luredFish.push(f);
                }
            }

            a.x += Math.sin(now * 0.0008) * 0.1 * dt;
            if (now - a._lureStart > a.lureDuration) { a.phase = 2; a._snapStart = now; }
        }

        if (a.phase === 2) {
            // SNAP ‚Äî jaw opens wide then closes
            var snapT = (now - a._snapStart) / 600;
            a.jawOpen = snapT < 0.3 ? snapT / 0.3 : Math.max(0, 1 - (snapT - 0.3) / 0.3);
            if (snapT > 0.3 && snapT < 0.5) {
                // Scatter lured fish
                a.luredFish.forEach(function(f) {
                    if (!f.alive || f.scooped) return;
                    var dx = f.x - a.x;
                    var dy = f.y - a.y;
                    var dist = Math.sqrt(dx * dx + dy * dy) || 1;
                    f.vx += (dx / dist) * 4;
                    f.vy += (dy / dist) * 3;
                    spawnBubble(f.x, f.y, 1);
                });
                spawnBubble(a.x, a.y, 3);
            }
            if (snapT > 1) { a.phase = 3; }
        }

        if (a.phase === 3) {
            // Slink back into the deep
            a.y += 0.5 * dt;
            a.x -= a.dir * 0.3 * dt;
            a.alpha -= 0.006 * dt;
            if (a.alpha <= 0 || a.y > H + 60) {
                anglerfish = null;
                feedInfo('<span style="color:#a78bfa;">ü™º The anglerfish retreats to the abyss</span>');
            }
        }
    }

    function drawAnglerfish(now) {
        if (!anglerfish) return;
        var a = anglerfish;
        var s = a.size;
        ctx.save();
        ctx.globalAlpha = Math.max(0, a.alpha);
        ctx.translate(a.x, a.y);
        if (a.dir < 0) ctx.scale(-1, 1);

        // Body ‚Äî bulbous, dark
        var tailAng = Math.sin(a.tailPhase) * 0.2;
        ctx.beginPath();
        ctx.moveTo(s * 0.7, s * 0.05 * (1 + a.jawOpen * 3));
        ctx.bezierCurveTo(s * 0.5, -s * 0.55, -s * 0.4, -s * 0.5, -s * 0.6, -s * 0.1);
        ctx.quadraticCurveTo(-s * 0.8 + tailAng * 10, 0, -s * 0.6, s * 0.1);
        ctx.bezierCurveTo(-s * 0.4, s * 0.5, s * 0.5, s * 0.55, s * 0.7, -s * 0.05 * (1 + a.jawOpen * 3));
        ctx.closePath();
        var bodyG = ctx.createRadialGradient(0, 0, s * 0.1, 0, 0, s * 0.7);
        bodyG.addColorStop(0, 'rgba(30,15,40,0.9)');
        bodyG.addColorStop(1, 'rgba(15,8,20,0.7)');
        ctx.fillStyle = bodyG;
        ctx.fill();

        // Jaw ‚Äî opens during snap
        if (a.jawOpen > 0.01) {
            ctx.beginPath();
            ctx.moveTo(s * 0.7, s * 0.05);
            ctx.lineTo(s * 0.9, s * 0.15 + a.jawOpen * s * 0.3);
            ctx.lineTo(s * 0.3, s * 0.1 + a.jawOpen * s * 0.15);
            ctx.closePath();
            ctx.fillStyle = 'rgba(60,10,20,0.8)';
            ctx.fill();
            // Teeth
            for (var t = 0; t < 4; t++) {
                var tx = s * 0.4 + t * s * 0.12;
                ctx.beginPath();
                ctx.moveTo(tx, s * 0.05);
                ctx.lineTo(tx + s * 0.03, s * 0.05 + a.jawOpen * s * 0.12);
                ctx.lineTo(tx - s * 0.03, s * 0.05 + a.jawOpen * s * 0.08);
                ctx.closePath();
                ctx.fillStyle = 'rgba(200,200,180,0.6)';
                ctx.fill();
            }
        }

        // Eye ‚Äî small, beady, bioluminescent
        ctx.beginPath();
        ctx.arc(s * 0.25, -s * 0.18, s * 0.06, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(160,100,220,0.9)';
        ctx.fill();

        // Lure stalk + light
        if (a.phase >= 1) {
            var lurePulse = 0.6 + Math.sin(a.glowPhase * 3) * 0.4;
            // Stalk
            ctx.beginPath();
            ctx.moveTo(s * 0.15, -s * 0.45);
            ctx.quadraticCurveTo(s * 0.25, a.lureY - s * 0.2, s * 0.3, a.lureY);
            ctx.strokeStyle = 'rgba(80,50,100,0.5)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            // Lure glow
            var lGlow = ctx.createRadialGradient(s * 0.3, a.lureY, 0, s * 0.3, a.lureY, s * 0.5);
            lGlow.addColorStop(0, 'rgba(180,130,255,' + (0.4 * lurePulse).toFixed(3) + ')');
            lGlow.addColorStop(0.3, 'rgba(140,80,220,' + (0.15 * lurePulse).toFixed(3) + ')');
            lGlow.addColorStop(1, 'rgba(100,50,180,0)');
            ctx.fillStyle = lGlow;
            ctx.beginPath();
            ctx.arc(s * 0.3, a.lureY, s * 0.5, 0, Math.PI * 2);
            ctx.fill();
            // Lure orb
            ctx.beginPath();
            ctx.arc(s * 0.3, a.lureY, s * 0.06, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(220,180,255,' + (0.7 + lurePulse * 0.3).toFixed(2) + ')';
            ctx.fill();
        }

        ctx.restore();
    }

    // ‚îÄ‚îÄ 7) TREASURE DROP ‚Äî golden coin sinks, fish follow ‚îÄ‚îÄ
    var treasure = null;

    function triggerTreasureDrop() {
        if (treasure) return;
        treasure = {
            x: W * 0.2 + Math.random() * W * 0.6,
            y: -20,
            targetY: H - 30,
            vy: 0,
            rotation: 0,
            rotSpeed: 0.02 + Math.random() * 0.03,
            size: 14,
            phase: 0, // 0=sinking, 1=resting, 2=dissolve
            startTime: performance.now(),
            glowPhase: 0,
            sparkles: [],
        };
        feedInfo('<span style="color:var(--gold);">ü™ô A golden coin drops from the surface!</span>');
    }

    function updateTreasureDrop(now, dt) {
        if (!treasure) return;
        var tr = treasure;
        var elapsed = now - tr.startTime;
        tr.rotation += tr.rotSpeed * dt;
        tr.glowPhase += 0.025 * dt;

        if (tr.phase === 0) {
            // Sinking with gentle wobble
            tr.vy = Math.min(tr.vy + 0.015 * dt, 1.2);
            tr.y += tr.vy * dt;
            tr.x += Math.sin(now * 0.002) * 0.3 * dt;

            // Attract nearby fish
            for (var i = 0; i < fishes.length; i++) {
                var f = fishes[i];
                if (f.scooped || f.rbfEaten) continue;
                var dx = tr.x - f.x;
                var dy = tr.y - f.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 120 && dist > 15) {
                    f.vx += (dx / dist) * 0.01 * dt;
                    f.vy += (dy / dist) * 0.008 * dt;
                }
            }

            // Trail sparkles
            if (Math.random() < 0.15) {
                tr.sparkles.push({
                    x: tr.x + (Math.random() - 0.5) * 12,
                    y: tr.y + (Math.random() - 0.5) * 8,
                    life: 1, decay: 0.015 + Math.random() * 0.02,
                    size: 1 + Math.random() * 2,
                });
            }

            if (tr.y >= tr.targetY) {
                tr.phase = 1; tr._restStart = now;
                spawnSediment(tr.x);
                spawnBubble(tr.x, tr.y, 1.5);
            }
        }

        if (tr.phase === 1) {
            // Resting on seabed, glowing
            tr.y = tr.targetY + Math.sin(now * 0.003) * 0.5;
            if (now - tr._restStart > 5000) { tr.phase = 2; tr._dissolveStart = now; }
        }

        if (tr.phase === 2) {
            // Dissolve into sparkles
            var dissolveT = (now - tr._dissolveStart) / 2000;
            tr.size = 14 * (1 - dissolveT);
            // Burst sparkles
            if (dissolveT < 0.3 && Math.random() < 0.3) {
                for (var j = 0; j < 3; j++) {
                    tr.sparkles.push({
                        x: tr.x + (Math.random() - 0.5) * 20,
                        y: tr.y + (Math.random() - 0.5) * 20,
                        life: 1, decay: 0.01 + Math.random() * 0.01,
                        size: 1.5 + Math.random() * 2.5,
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: -(Math.random() * 2),
                    });
                }
            }
            if (dissolveT > 1) { treasure = null; return; }
        }

        // Update sparkles
        for (var k = tr.sparkles.length - 1; k >= 0; k--) {
            var sp = tr.sparkles[k];
            sp.life -= sp.decay;
            if (sp.vx) { sp.x += (sp.vx || 0); sp.y += (sp.vy || 0); sp.vy += 0.01; }
            if (sp.life <= 0) tr.sparkles.splice(k, 1);
        }
    }

    function drawTreasureDrop(now) {
        if (!treasure) return;
        var tr = treasure;
        var pulse = 0.6 + Math.sin(tr.glowPhase) * 0.4;

        // Coin glow
        var glow = ctx.createRadialGradient(tr.x, tr.y, 0, tr.x, tr.y, tr.size * 4);
        glow.addColorStop(0, 'rgba(247,147,26,' + (0.15 * pulse).toFixed(3) + ')');
        glow.addColorStop(0.5, 'rgba(247,147,26,' + (0.04 * pulse).toFixed(3) + ')');
        glow.addColorStop(1, 'rgba(247,147,26,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(tr.x, tr.y, tr.size * 4, 0, Math.PI * 2);
        ctx.fill();

        // BC2 coin ‚Äî actual logo image with 3D spin
        var wobble = Math.abs(Math.cos(tr.rotation));
        ctx.save();
        ctx.translate(tr.x, tr.y);
        ctx.scale(wobble, 1); // 3D spin flattening

        var r = tr.size;

        // Draw the logo image (circular, centered)
        if (bc2Logo.complete && bc2Logo.naturalWidth > 0) {
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(bc2Logo, -r, -r, r * 2, r * 2);
        } else {
            // Fallback orange circle
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fillStyle = '#F7931A';
            ctx.fill();
        }

        ctx.restore();

        // Sparkles
        for (var i = 0; i < tr.sparkles.length; i++) {
            var sp = tr.sparkles[i];
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, sp.size * sp.life, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,215,0,' + (sp.life * 0.7).toFixed(3) + ')';
            ctx.fill();
        }
    }

    // ‚îÄ‚îÄ 8) BAITBALL ‚Äî tiny fry swirl in a defensive sphere ‚îÄ‚îÄ
    var baitball = null;

    function triggerBaitball() {
        if (baitball) return;
        var cx = W * 0.2 + Math.random() * W * 0.6;
        var cy = H * 0.2 + Math.random() * H * 0.4;
        var fryCount = 40 + Math.floor(Math.random() * 40);
        var fry = [];
        for (var i = 0; i < fryCount; i++) {
            var angle = Math.random() * Math.PI * 2;
            var radius = 20 + Math.random() * 40;
            fry.push({
                angle: angle,
                radius: radius,
                baseRadius: radius,
                speed: 0.01 + Math.random() * 0.015,
                size: 1.5 + Math.random() * 2,
                offset: Math.random() * Math.PI * 2,
            });
        }
        baitball = {
            x: cx, y: cy,
            fry: fry,
            startTime: performance.now(),
            duration: 6000 + Math.random() * 5000,
            vx: (Math.random() - 0.5) * 0.4,
            vy: (Math.random() - 0.5) * 0.2,
            pulsePhase: 0,
        };
        feedInfo('<span style="color:#38bdf8;">üêü A school of fry forms a baitball!</span>');
    }

    function updateBaitball(now, dt) {
        if (!baitball) return;
        var bb = baitball;
        var elapsed = now - bb.startTime;
        if (elapsed > bb.duration) { baitball = null; return; }

        bb.pulsePhase += 0.02 * dt;
        var pulse = 1 + Math.sin(bb.pulsePhase) * 0.15;

        // Drift slowly
        bb.x += bb.vx * dt;
        bb.y += bb.vy * dt;
        bb.x = Math.max(60, Math.min(W - 60, bb.x));
        bb.y = Math.max(40, Math.min(H - 60, bb.y));

        // Check for nearby predator or large fish ‚Äî contract
        var threat = false;
        if (predator) {
            var pdx = predator.x - bb.x;
            var pdy = predator.y - bb.y;
            if (Math.sqrt(pdx * pdx + pdy * pdy) < 200) threat = true;
        }
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.size < 20 || f.scooped) continue;
            var fdx = f.x - bb.x;
            var fdy = f.y - bb.y;
            if (Math.sqrt(fdx * fdx + fdy * fdy) < 120) { threat = true; break; }
        }

        // Update fry
        var targetRadius = threat ? 0.5 : 1;
        for (var j = 0; j < bb.fry.length; j++) {
            var fr = bb.fry[j];
            fr.angle += fr.speed * dt;
            var rTarget = fr.baseRadius * targetRadius * pulse;
            fr.radius += (rTarget - fr.radius) * 0.05 * dt;
        }

        // Fade at edges
        var progress = elapsed / bb.duration;
        bb._alpha = progress < 0.1 ? progress / 0.1 : (progress > 0.85 ? (1 - progress) / 0.15 : 1);
    }

    function drawBaitball(now) {
        if (!baitball) return;
        var bb = baitball;
        var alpha = bb._alpha || 1;
        ctx.save();
        ctx.globalAlpha = alpha;
        for (var i = 0; i < bb.fry.length; i++) {
            var fr = bb.fry[i];
            var fx = bb.x + Math.cos(fr.angle + fr.offset) * fr.radius;
            var fy = bb.y + Math.sin(fr.angle + fr.offset) * fr.radius;
            ctx.beginPath();
            ctx.arc(fx, fy, fr.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(180,220,240,0.5)';
            ctx.fill();
            // Tiny glow
            ctx.beginPath();
            ctx.arc(fx, fy, fr.size * 2.5, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(56,189,248,0.03)';
            ctx.fill();
        }
        ctx.restore();
    }

    // ‚îÄ‚îÄ 9) AURORA BOREALIS ‚Äî light bands ripple across the surface ‚îÄ‚îÄ
    var aurora = null;

    function triggerAurora() {
        if (aurora) return;
        var bands = [];
        var bandCount = 4 + Math.floor(Math.random() * 3);
        for (var i = 0; i < bandCount; i++) {
            bands.push({
                y: H * 0.02 + i * H * 0.06,
                width: H * 0.04 + Math.random() * H * 0.05,
                hue: [
                    { r: 74, g: 234, b: 188 },
                    { r: 56, g: 189, b: 248 },
                    { r: 140, g: 100, b: 220 },
                    { r: 247, g: 147, b: 26 },
                ][Math.floor(Math.random() * 4)],
                speed: 0.0005 + Math.random() * 0.001,
                phase: Math.random() * Math.PI * 2,
                amplitude: 5 + Math.random() * 10,
            });
        }
        aurora = {
            bands: bands,
            startTime: performance.now(),
            duration: 12000 + Math.random() * 8000,
        };
        feedInfo('<span style="color:#4AEABC;">‚ú® The aurora shimmers above‚Ä¶</span>');
    }

    function drawAurora(now) {
        if (!aurora) return;
        var elapsed = now - aurora.startTime;
        if (elapsed > aurora.duration) { aurora = null; return; }

        var fadeIn = Math.min(1, elapsed / 2000);
        var fadeOut = Math.max(0, 1 - (elapsed - aurora.duration * 0.7) / (aurora.duration * 0.3));
        var intensity = fadeIn * fadeOut;
        if (intensity < 0.005) return;

        for (var i = 0; i < aurora.bands.length; i++) {
            var b = aurora.bands[i];
            var wave = Math.sin(now * b.speed + b.phase);
            var yOff = b.y + wave * b.amplitude;
            var grad = ctx.createLinearGradient(0, yOff, 0, yOff + b.width);
            var a = intensity * 0.06;
            grad.addColorStop(0, 'rgba(' + b.hue.r + ',' + b.hue.g + ',' + b.hue.b + ',0)');
            grad.addColorStop(0.3, 'rgba(' + b.hue.r + ',' + b.hue.g + ',' + b.hue.b + ',' + a.toFixed(4) + ')');
            grad.addColorStop(0.7, 'rgba(' + b.hue.r + ',' + b.hue.g + ',' + b.hue.b + ',' + (a * 0.7).toFixed(4) + ')');
            grad.addColorStop(1, 'rgba(' + b.hue.r + ',' + b.hue.g + ',' + b.hue.b + ',0)');
            ctx.fillStyle = grad;

            // Wavy band shape
            ctx.beginPath();
            ctx.moveTo(0, yOff);
            for (var x = 0; x <= W; x += 20) {
                var waveY = yOff + Math.sin(x * 0.008 + now * 0.001 + b.phase) * b.amplitude * 0.3;
                ctx.lineTo(x, waveY);
            }
            ctx.lineTo(W, yOff + b.width);
            for (var x2 = W; x2 >= 0; x2 -= 20) {
                var waveY2 = yOff + b.width + Math.sin(x2 * 0.008 + now * 0.0012 + b.phase + 1) * b.amplitude * 0.2;
                ctx.lineTo(x2, waveY2);
            }
            ctx.closePath();
            ctx.fill();
        }
    }

    // ‚îÄ‚îÄ 10) KRAKEN TENTACLE ‚Äî a single tentacle reaches in ‚îÄ‚îÄ
    var kraken = null;

    function triggerKraken() {
        if (kraken) return;
        var side = Math.random() > 0.5 ? 'right' : 'left';
        var segments = 16;
        var segs = [];
        for (var i = 0; i < segments; i++) {
            segs.push({ angle: 0, targetAngle: 0 });
        }
        kraken = {
            side: side,
            startX: side === 'right' ? W + 20 : -20,
            y: H * 0.2 + Math.random() * H * 0.4,
            segments: segs,
            segLength: 22,
            phase: 0, // 0=reaching, 1=searching, 2=recoiling
            startTime: performance.now(),
            reachDuration: 3500,
            searchDuration: 10000 + Math.random() * 8000,
            thickness: 18,
            alpha: 0,
            sweepAngle: 0, // current sweep position
            sweepSpeed: 0.004 + Math.random() * 0.002, // faster visible sweeps
            sweepRange: 0.6 + Math.random() * 0.4, // wider sweep arc
            recoilProgress: 0,
        };
        feedInfo('<span style="color:#ef4444;">ü¶ë Something ancient stirs at the edge‚Ä¶</span>');
    }

    function updateKraken(now, dt) {
        if (!kraken) return;
        var k = kraken;
        var elapsed = now - k.startTime;
        var dir = k.side === 'right' ? -1 : 1;

        if (k.phase === 0) {
            // Reaching in ‚Äî curl segments progressively
            k.alpha = Math.min(1, elapsed / 800);
            var reach = Math.min(1, elapsed / k.reachDuration);
            for (var i = 0; i < k.segments.length; i++) {
                var t = i / k.segments.length;
                k.segments[i].targetAngle = dir * (0.15 + t * 0.25) * reach;
                k.segments[i].targetAngle += Math.sin(now * 0.002 + i * 0.5) * 0.05 * reach;
            }
            if (elapsed > k.reachDuration) { k.phase = 1; k._searchStart = now; }
        }

        if (k.phase === 1) {
            // Searching ‚Äî sweep back and forth
            k.sweepAngle += k.sweepSpeed * dt;
            var sweep = Math.sin(k.sweepAngle) * k.sweepRange;

            for (var i = 0; i < k.segments.length; i++) {
                var t = i / k.segments.length;
                // Base curl inward
                var base = dir * (0.15 + t * 0.2);
                // Sweep offset ‚Äî stronger at tip
                var sweepEffect = sweep * (0.3 + t * 0.7);
                // Writhing detail
                var writhe = Math.sin(now * 0.003 + i * 0.8) * (0.06 + t * 0.08);
                var writhe2 = Math.sin(now * 0.005 + i * 1.4) * 0.03;

                k.segments[i].targetAngle = base + sweepEffect + writhe + writhe2;
            }

            // Scare nearby fish from tip AND along the whole tentacle
            var tipX = k._tipX || k.startX;
            var tipY = k._tipY || k.y;
            for (var j = 0; j < fishes.length; j++) {
                var f = fishes[j];
                if (f.scooped) continue;
                var dx = f.x - tipX;
                var dy = f.y - tipY;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < 120 && dist > 0) {
                    f.vx += (dx / dist) * 0.25 * dt;
                    f.vy += (dy / dist) * 0.12 * dt;
                }
            }
            // Also scare from mid-body points
            if (k._midPoints) {
                for (var mp = 0; mp < k._midPoints.length; mp++) {
                    var mid = k._midPoints[mp];
                    for (var j = 0; j < fishes.length; j++) {
                        var f = fishes[j];
                        if (f.scooped) continue;
                        var dx = f.x - mid.x;
                        var dy = f.y - mid.y;
                        var dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 60 && dist > 0) {
                            f.vx += (dx / dist) * 0.1 * dt;
                            f.vy += (dy / dist) * 0.05 * dt;
                        }
                    }
                }
            }

            if (now - k._searchStart > k.searchDuration) {
                k.phase = 2;
                k._recoilStart = now;
                k.recoilProgress = 0;
            }
        }

        if (k.phase === 2) {
            // Recoiling ‚Äî snap back fast like startled octopus
            k.recoilProgress += 0.012 * dt;
            var recoil = Math.min(1, k.recoilProgress);
            // Fast ease out ‚Äî snappy start
            var ease = 1 - (1 - recoil) * (1 - recoil) * (1 - recoil);

            for (var i = 0; i < k.segments.length; i++) {
                var t = i / k.segments.length;
                // Snap fully straight toward exit
                var retractAngle = dir * 0.01 * (1 - t);
                k.segments[i].targetAngle = k.segments[i].angle * (1 - ease) + retractAngle * ease;

                // Whip crack propagates base ‚Üí tip
                if (recoil < 0.4) {
                    var whipDelay = t * 0.2;
                    var whipT = Math.max(0, recoil - whipDelay) / 0.2;
                    if (whipT > 0 && whipT < 1) {
                        k.segments[i].targetAngle += Math.sin(whipT * Math.PI) * dir * -0.25;
                    }
                }
            }

            // Fade out during second half of recoil
            if (ease > 0.4) {
                k.alpha -= 0.018 * dt;
            }

            if (k.alpha <= 0 || ease >= 1) {
                kraken = null;
                feedInfo('<span style="color:#ef4444;">ü¶ë The tentacle snaps back into the darkness</span>');
                return;
            }
        }

        // Smooth segment angles
        if (k) {
            var smoothRate = k.phase === 2 ? 0.22 : 0.08;
            for (var i = 0; i < k.segments.length; i++) {
                k.segments[i].angle += (k.segments[i].targetAngle - k.segments[i].angle) * smoothRate * dt;
            }
        }
    }

    function drawKraken(now) {
        if (!kraken) return;
        var k = kraken;
        ctx.save();
        ctx.globalAlpha = Math.max(0, k.alpha);

        var x = k.startX;
        var y = k.y;
        var angle = 0;
        var points = [{ x: x, y: y }];

        for (var i = 0; i < k.segments.length; i++) {
            angle += k.segments[i].angle;
            x += Math.cos(angle) * k.segLength;
            y += Math.sin(angle) * k.segLength;
            points.push({ x: x, y: y });
        }
        k._tipX = x; k._tipY = y;

        // Store mid-body scare points
        k._midPoints = [];
        if (points.length > 6) {
            k._midPoints.push(points[Math.floor(points.length * 0.3)]);
            k._midPoints.push(points[Math.floor(points.length * 0.6)]);
        }

        // Draw tentacle as tapered shape
        for (var i = 0; i < points.length - 1; i++) {
            var p1 = points[i];
            var p2 = points[i + 1];
            var t = i / points.length;
            var thick = k.thickness * (1 - t * 0.7);

            ctx.beginPath();
            var dx = p2.x - p1.x;
            var dy = p2.y - p1.y;
            var len = Math.sqrt(dx * dx + dy * dy) || 1;
            var nx = -dy / len * thick / 2;
            var ny = dx / len * thick / 2;
            ctx.moveTo(p1.x + nx, p1.y + ny);
            ctx.lineTo(p2.x + nx * 0.8, p2.y + ny * 0.8);
            ctx.lineTo(p2.x - nx * 0.8, p2.y - ny * 0.8);
            ctx.lineTo(p1.x - nx, p1.y - ny);
            ctx.closePath();
            ctx.fillStyle = 'rgba(80,25,35,' + (0.7 - t * 0.3).toFixed(2) + ')';
            ctx.fill();

            // Suckers on underside
            if (i > 1 && i % 2 === 0) {
                var cx = (p1.x + p2.x) / 2 - nx * 0.5;
                var cy = (p1.y + p2.y) / 2 - ny * 0.5;
                ctx.beginPath();
                ctx.arc(cx, cy, thick * 0.15, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(120,50,60,0.4)';
                ctx.fill();
            }
        }

        // Tip glow ‚Äî pulses during search
        var tip = points[points.length - 1];
        var glowSize = k.phase === 1 ? 25 + Math.sin(now * 0.004) * 8 : 20;
        var tipGlow = ctx.createRadialGradient(tip.x, tip.y, 0, tip.x, tip.y, glowSize);
        tipGlow.addColorStop(0, 'rgba(200,60,60,' + (k.phase === 1 ? '0.12' : '0.06') + ')');
        tipGlow.addColorStop(1, 'rgba(200,60,60,0)');
        ctx.fillStyle = tipGlow;
        ctx.beginPath();
        ctx.arc(tip.x, tip.y, glowSize, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ‚îÄ‚îÄ 11) SATOSHI'S GHOST ‚Äî legendary ultra-rare golden spectral whale ‚îÄ‚îÄ
    var satoshiGhost = null;

    function triggerSatoshiGhost() {
        if (satoshiGhost) return;
        satoshiGhost = {
            x: -250,
            y: H * 0.35 + (Math.random() - 0.5) * H * 0.15,
            startTime: performance.now(),
            duration: 18000,
            alpha: 0,
            glowPhase: 0,
        };
        feedInfo('<span style="color:#FFD700;">üëÅ <i>"If you don\'t believe me or don\'t understand, I don\'t have time to try to convince you."</i></span>');
    }

    function updateSatoshiGhost(now, dt) {
        if (!satoshiGhost) return;
        var sg = satoshiGhost;
        var elapsed = now - sg.startTime;
        sg.glowPhase += 0.015 * dt;

        var progress = elapsed / sg.duration;
        if (progress > 1) { satoshiGhost = null; return; }

        // Slow glide across
        var ease = progress;
        sg.x = -250 + ease * (W + 500);
        sg.y = sg.y + Math.sin(now * 0.0006) * 0.15 * dt;

        // Fade: appear slowly, hold, fade
        if (progress < 0.15) sg.alpha = progress / 0.15 * 0.35;
        else if (progress > 0.8) sg.alpha = (1 - progress) / 0.2 * 0.35;
        else sg.alpha = 0.35;

        // Fish part reverently ‚Äî push them away gently
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            var dx = f.x - sg.x;
            var dy = f.y - sg.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 180 && dist > 0) {
                var push = (1 - dist / 180) * 0.08 * dt;
                f.vx += (dx / dist) * push;
                f.vy += (dy / dist) * push * 0.5;
            }
        }
    }

    function drawSatoshiGhost(now) {
        if (!satoshiGhost) return;
        var sg = satoshiGhost;
        var w = 200;
        var h = 80;
        ctx.save();
        ctx.globalAlpha = sg.alpha;
        ctx.translate(sg.x, sg.y);

        // Ethereal golden glow
        var pulse = 0.7 + Math.sin(sg.glowPhase) * 0.3;
        var glow = ctx.createRadialGradient(w * 0.4, 0, 10, w * 0.4, 0, w);
        glow.addColorStop(0, 'rgba(255,215,0,' + (0.12 * pulse).toFixed(3) + ')');
        glow.addColorStop(0.3, 'rgba(247,147,26,' + (0.05 * pulse).toFixed(3) + ')');
        glow.addColorStop(1, 'rgba(247,147,26,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(w * 0.4, 0, w, 0, Math.PI * 2);
        ctx.fill();

        // Ghost whale body ‚Äî translucent gold
        ctx.beginPath();
        ctx.moveTo(w, 0);
        ctx.bezierCurveTo(w * 0.8, -h * 0.5, w * 0.4, -h * 0.55, w * 0.2, -h * 0.3);
        ctx.bezierCurveTo(w * 0.08, -h * 0.15, 0, -h * 0.1, -w * 0.05, -h * 0.05);
        ctx.lineTo(-w * 0.2, -h * 0.5);
        ctx.lineTo(-w * 0.08, 0);
        ctx.lineTo(-w * 0.2, h * 0.5);
        ctx.lineTo(-w * 0.05, h * 0.05);
        ctx.bezierCurveTo(0, h * 0.1, w * 0.08, h * 0.15, w * 0.2, h * 0.3);
        ctx.bezierCurveTo(w * 0.4, h * 0.55, w * 0.8, h * 0.5, w, 0);
        ctx.closePath();

        var bodyGrad = ctx.createLinearGradient(0, -h * 0.4, w * 0.5, h * 0.4);
        bodyGrad.addColorStop(0, 'rgba(255,215,0,0.3)');
        bodyGrad.addColorStop(0.5, 'rgba(247,147,26,0.2)');
        bodyGrad.addColorStop(1, 'rgba(184,134,11,0.15)');
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,215,0,0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Eye ‚Äî wise, glowing
        ctx.beginPath();
        ctx.arc(w * 0.72, -h * 0.12, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fill();
        var eyeGlow = ctx.createRadialGradient(w * 0.72, -h * 0.12, 0, w * 0.72, -h * 0.12, 15);
        eyeGlow.addColorStop(0, 'rgba(255,215,0,0.2)');
        eyeGlow.addColorStop(1, 'rgba(255,215,0,0)');
        ctx.fillStyle = eyeGlow;
        ctx.beginPath();
        ctx.arc(w * 0.72, -h * 0.12, 15, 0, Math.PI * 2);
        ctx.fill();

        // BC2 logo on the body ‚Äî spectral image
        var logoX = w * 0.45;
        var logoY = 0;
        var logoR = 18;
        var logoA = 0.18 * pulse;

        if (bc2Logo.complete && bc2Logo.naturalWidth > 0) {
            ctx.save();
            ctx.globalAlpha = logoA;
            ctx.beginPath();
            ctx.arc(logoX, logoY, logoR, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(bc2Logo, logoX - logoR, logoY - logoR, logoR * 2, logoR * 2);
            ctx.restore();
        }

        // Particle trail
        for (var i = 0; i < 5; i++) {
            var px = -w * 0.15 - i * 15 + Math.sin(now * 0.003 + i) * 5;
            var py = Math.sin(now * 0.002 + i * 2) * 8;
            var sparkAlpha = 0.1 - i * 0.018;
            if (sparkAlpha > 0) {
                ctx.beginPath();
                ctx.arc(px, py, 2.5 - i * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,215,0,' + sparkAlpha.toFixed(3) + ')';
                ctx.fill();
            }
        }

        ctx.restore();
    }

    // ‚îÄ‚îÄ 12) JELLYFISH DRIFT ‚Äî translucent bells pulse through ‚îÄ‚îÄ
    var jellyfishEvent = null;

    function triggerJellyfish() {
        if (jellyfishEvent) return;
        var count = 1 + Math.floor(Math.random() * 3);
        var jellies = [];
        for (var i = 0; i < count; i++) {
            jellies.push({
                x: Math.random() * W,
                y: -30 - i * 60,
                size: 14 + Math.random() * 16,
                pulsePhase: Math.random() * Math.PI * 2,
                pulseSpeed: 0.02 + Math.random() * 0.01,
                driftVx: (Math.random() - 0.5) * 0.2,
                tentaclePhase: Math.random() * Math.PI * 2,
                hue: Math.random() > 0.5 ?
                    { r: 160, g: 120, b: 255 } :
                    { r: 100, g: 200, b: 255 },
            });
        }
        jellyfishEvent = {
            jellies: jellies,
            startTime: performance.now(),
            duration: 15000 + Math.random() * 10000,
        };
        feedInfo('<span style="color:#a78bfa;">ü™º Jellyfish drift through the tank‚Ä¶</span>');
    }

    function updateJellyfish(now, dt) {
        if (!jellyfishEvent) return;
        var elapsed = now - jellyfishEvent.startTime;
        if (elapsed > jellyfishEvent.duration) { jellyfishEvent = null; return; }

        for (var i = 0; i < jellyfishEvent.jellies.length; i++) {
            var j = jellyfishEvent.jellies[i];
            j.pulsePhase += j.pulseSpeed * dt;
            j.tentaclePhase += 0.015 * dt;
            var pulseForce = Math.sin(j.pulsePhase);
            // Jellyfish move down in pulses
            j.y += (0.3 + (pulseForce > 0 ? pulseForce * 0.5 : 0)) * dt;
            j.x += j.driftVx * dt + Math.sin(now * 0.001 + i) * 0.05 * dt;

            // Fish avoid jellyfish
            for (var k = 0; k < fishes.length; k++) {
                var f = fishes[k];
                if (f.scooped || f.rbfEaten) continue;
                var dx = f.x - j.x;
                var dy = f.y - j.y;
                var dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < j.size * 3 && dist > 0) {
                    var repel = (1 - dist / (j.size * 3)) * 0.08 * dt;
                    f.vx += (dx / dist) * repel;
                    f.vy += (dy / dist) * repel;
                }
            }
        }
    }

    function drawJellyfish(now) {
        if (!jellyfishEvent) return;
        var elapsed = now - jellyfishEvent.startTime;
        var fadeIn = Math.min(1, elapsed / 2000);
        var fadeOut = Math.max(0, 1 - (elapsed - jellyfishEvent.duration * 0.8) / (jellyfishEvent.duration * 0.2));
        var alpha = fadeIn * fadeOut;

        for (var i = 0; i < jellyfishEvent.jellies.length; i++) {
            var j = jellyfishEvent.jellies[i];
            var s = j.size;
            var pulse = Math.sin(j.pulsePhase);
            var bellW = s * (0.8 + pulse * 0.2);
            var bellH = s * (0.6 + pulse * -0.15);
            var c = j.hue;

            ctx.save();
            ctx.globalAlpha = alpha * 0.6;
            ctx.translate(j.x, j.y);

            // Glow
            var glow = ctx.createRadialGradient(0, 0, 0, 0, 0, s * 2.5);
            glow.addColorStop(0, 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.06)');
            glow.addColorStop(1, 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0)');
            ctx.fillStyle = glow;
            ctx.beginPath();
            ctx.arc(0, 0, s * 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Bell (dome)
            ctx.beginPath();
            ctx.ellipse(0, -bellH * 0.2, bellW, bellH, 0, Math.PI, 0);
            var bellGrad = ctx.createRadialGradient(0, -bellH * 0.3, 2, 0, -bellH * 0.3, bellW);
            bellGrad.addColorStop(0, 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.35)');
            bellGrad.addColorStop(0.7, 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.12)');
            bellGrad.addColorStop(1, 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.04)');
            ctx.fillStyle = bellGrad;
            ctx.fill();

            // Bell rim
            ctx.beginPath();
            ctx.ellipse(0, -bellH * 0.2, bellW, 2, 0, 0, Math.PI);
            ctx.strokeStyle = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',0.25)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Tentacles ‚Äî 5 wavy strands
            for (var t = 0; t < 5; t++) {
                var tx = (t - 2) * bellW * 0.35;
                ctx.beginPath();
                ctx.moveTo(tx, 0);
                var tentLen = s * (1.2 + Math.random() * 0.3);
                for (var seg = 1; seg <= 6; seg++) {
                    var sy = seg * tentLen / 6;
                    var sx = tx + Math.sin(j.tentaclePhase + t * 0.8 + seg * 0.5) * (3 + seg);
                    ctx.lineTo(sx, sy);
                }
                ctx.strokeStyle = 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + (0.2 - t * 0.02).toFixed(2) + ')';
                ctx.lineWidth = 0.8;
                ctx.stroke();
            }

            // Inner organs ‚Äî tiny pulsing dots
            for (var o = 0; o < 3; o++) {
                var ox = (o - 1) * bellW * 0.3;
                var oy = -bellH * (0.35 + o * 0.08);
                ctx.beginPath();
                ctx.arc(ox, oy, 1.5 + pulse * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,' + (0.2 + pulse * 0.1).toFixed(2) + ')';
                ctx.fill();
            }

            ctx.restore();
        }
    }

    // ‚îÄ‚îÄ 13) SEAQUAKE ‚Äî the tank itself trembles ‚îÄ‚îÄ
    var seaquake = null;

    function triggerSeaquake() {
        if (seaquake) return;
        seaquake = {
            startTime: performance.now(),
            duration: 4000 + Math.random() * 2000,
            intensity: 0.5 + Math.random() * 0.5,
        };
        // Mass sediment eruption
        for (var i = 0; i < 15; i++) {
            spawnSediment(Math.random() * W);
        }
        // Scare all fish
        for (var j = 0; j < fishes.length; j++) {
            var f = fishes[j];
            if (f.scooped) continue;
            f.vx += (Math.random() - 0.5) * 3;
            f.vy += (Math.random() - 0.5) * 2;
        }
        feedInfo('<span style="color:#ef4444;">üåã Seaquake! The ocean floor trembles!</span>');
    }

    function updateSeaquake(now, dt) {
        if (!seaquake) return;
        var elapsed = now - seaquake.startTime;
        if (elapsed > seaquake.duration) { seaquake = null; return; }

        var progress = elapsed / seaquake.duration;
        var shake = seaquake.intensity * (1 - progress);

        // Periodic aftershock sediment
        if (Math.random() < 0.03 * shake) {
            spawnSediment(Math.random() * W);
        }
        // Occasional bubble burst from cracks
        if (Math.random() < 0.05 * shake) {
            spawnBubble(Math.random() * W, H - 15, 1.5);
        }
    }

    function drawSeaquake(now) {
        if (!seaquake) return;
        var elapsed = now - seaquake.startTime;
        var progress = elapsed / seaquake.duration;
        var shake = seaquake.intensity * Math.max(0, 1 - progress);

        // Dark red vignette pulse
        var vigAlpha = shake * 0.06;
        if (vigAlpha > 0.002) {
            var vig = ctx.createRadialGradient(W / 2, H / 2, W * 0.2, W / 2, H / 2, W * 0.7);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(120,30,20,' + vigAlpha.toFixed(4) + ')');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);
        }
    }

    // ‚îÄ‚îÄ 14) PLANKTON BLOOM ‚Äî cloud of green bioluminescence ‚îÄ‚îÄ
    var planktonBloom = null;

    function triggerPlanktonBloom() {
        if (planktonBloom) return;
        var cx = W * 0.15 + Math.random() * W * 0.7;
        var cy = H * 0.15 + Math.random() * H * 0.5;
        var particles = [];
        var count = 120 + Math.floor(Math.random() * 80);
        for (var i = 0; i < count; i++) {
            var angle = Math.random() * Math.PI * 2;
            var r = Math.random() * 80;
            particles.push({
                x: cx + Math.cos(angle) * r,
                y: cy + Math.sin(angle) * r,
                vx: (Math.random() - 0.5) * 0.3,
                vy: (Math.random() - 0.5) * 0.2,
                size: 0.8 + Math.random() * 1.5,
                phase: Math.random() * Math.PI * 2,
                life: 1,
            });
        }
        planktonBloom = {
            particles: particles,
            cx: cx, cy: cy,
            startTime: performance.now(),
            duration: 10000 + Math.random() * 5000,
        };
        feedInfo('<span style="color:#4aea70;">ü¶† Plankton bloom! Fish flock to feed‚Ä¶</span>');
    }

    function updatePlanktonBloom(now, dt) {
        if (!planktonBloom) return;
        var pb = planktonBloom;
        var elapsed = now - pb.startTime;
        if (elapsed > pb.duration) { planktonBloom = null; return; }

        var progress = elapsed / pb.duration;
        var fadeOut = progress > 0.7 ? (1 - progress) / 0.3 : 1;

        for (var i = pb.particles.length - 1; i >= 0; i--) {
            var p = pb.particles[i];
            p.x += p.vx * dt + Math.sin(now * 0.002 + p.phase) * 0.05 * dt;
            p.y += p.vy * dt + Math.cos(now * 0.0015 + p.phase) * 0.04 * dt;
            p.phase += 0.02 * dt;
            // Slowly disperse
            var dx = p.x - pb.cx;
            var dy = p.y - pb.cy;
            p.x += dx * 0.0002 * dt;
            p.y += dy * 0.0002 * dt;
            p.life = fadeOut;
        }

        // Fish attracted to bloom center ‚Äî strong pull
        for (var j = 0; j < fishes.length; j++) {
            var f = fishes[j];
            if (f.scooped || f.rbfEaten || f.size > 25) continue;
            var fdx = pb.cx - f.x;
            var fdy = pb.cy - f.y;
            var dist = Math.sqrt(fdx * fdx + fdy * fdy);
            if (dist < 300 && dist > 15) {
                var pull = (1 - dist / 300) * 0.06 * fadeOut;
                f.vx += (fdx / dist) * pull * dt;
                f.vy += (fdy / dist) * pull * 0.7 * dt;
                // Fish feeding near bloom wiggle faster
                if (dist < 60) {
                    f.tailSpeed = Math.max(f.tailSpeed, 5 + Math.random());
                }
            }
        }
    }

    function drawPlanktonBloom(now) {
        if (!planktonBloom) return;
        var pb = planktonBloom;
        for (var i = 0; i < pb.particles.length; i++) {
            var p = pb.particles[i];
            var flicker = 0.3 + Math.sin(p.phase) * 0.2;
            var a = p.life * flicker;
            if (a < 0.01) continue;
            // Green-gold bioluminescent dot
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(120,230,80,' + (a * 0.6).toFixed(3) + ')';
            ctx.fill();
            // Glow halo
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(120,230,80,' + (a * 0.04).toFixed(4) + ')';
            ctx.fill();
        }
    }

    // ‚îÄ‚îÄ 15) MESSAGE IN A BOTTLE ‚Äî sinks with a Satoshi quote ‚îÄ‚îÄ
    var bottleMsg = null;
    var satoshiQuotes = [
        "The root problem with conventional currency is all the trust that's required to make it work.",
        "If you don't believe me or don't understand, I don't have time to try to convince you.",
        "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks.",
        "Lost coins only make everyone else's coins worth slightly more.",
        "I've been working on a new electronic cash system that's fully peer-to-peer.",
        "It might make sense just to get some in case it catches on.",
        "The nature of Bitcoin is such that once version 0.1 was released, the core design was set in stone.",
        "Writing a description for this thing for general audiences is bloody hard.",
        "I'm sure that in 20 years there will either be very large transaction volume or no volume.",
        "In a few decades, when the reward gets too small, the transaction fee will become the main compensation.",
    ];

    function triggerBottleMessage() {
        if (bottleMsg) return;
        bottleMsg = {
            x: W * 0.2 + Math.random() * W * 0.6,
            y: -20,
            targetY: H * 0.4 + Math.random() * H * 0.3,
            vy: 0,
            rotation: (Math.random() - 0.5) * 0.3,
            rotSpeed: (Math.random() - 0.5) * 0.005,
            phase: 0, // 0=sinking, 1=floating/reveal, 2=dissolve
            startTime: performance.now(),
            quote: satoshiQuotes[Math.floor(Math.random() * satoshiQuotes.length)],
            quoteAlpha: 0,
            alpha: 0,
        };
        feedInfo('<span style="color:var(--gold);">üìú A message in a bottle drifts down‚Ä¶</span>');
    }

    function updateBottleMessage(now, dt) {
        if (!bottleMsg) return;
        var b = bottleMsg;
        var elapsed = now - b.startTime;
        b.rotation += b.rotSpeed * dt;

        if (b.phase === 0) {
            b.alpha = Math.min(1, elapsed / 1000);
            b.vy = Math.min(b.vy + 0.008 * dt, 0.8);
            b.y += b.vy * dt;
            b.x += Math.sin(now * 0.0015) * 0.2 * dt;
            if (b.y >= b.targetY) { b.phase = 1; b._revealStart = now; }
        }

        if (b.phase === 1) {
            // Gently bobbing, quote fades in
            b.y = b.targetY + Math.sin(now * 0.002) * 3;
            b.x += Math.sin(now * 0.001) * 0.08 * dt;
            var revealElapsed = now - b._revealStart;
            b.quoteAlpha = Math.min(0.85, revealElapsed / 2000);
            if (revealElapsed > 8000) { b.phase = 2; b._dissolveStart = now; }
        }

        if (b.phase === 2) {
            var dissolveT = (now - b._dissolveStart) / 3000;
            b.alpha = Math.max(0, 1 - dissolveT);
            b.quoteAlpha = Math.max(0, b.quoteAlpha * (1 - dissolveT));
            b.y -= 0.2 * dt; // drift up as it fades
            if (dissolveT > 1) { bottleMsg = null; }
        }
    }

    function drawBottleMessage(now) {
        if (!bottleMsg) return;
        var b = bottleMsg;
        ctx.save();
        ctx.globalAlpha = b.alpha;
        ctx.translate(b.x, b.y);
        ctx.rotate(b.rotation);

        // Bottle body
        ctx.beginPath();
        ctx.moveTo(-4, -8);
        ctx.lineTo(-3, -12);
        ctx.lineTo(3, -12);
        ctx.lineTo(4, -8);
        ctx.bezierCurveTo(6, -4, 6, 6, 4, 10);
        ctx.lineTo(-4, 10);
        ctx.bezierCurveTo(-6, 6, -6, -4, -4, -8);
        ctx.closePath();
        ctx.fillStyle = 'rgba(100,180,140,0.35)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(150,220,180,0.4)';
        ctx.lineWidth = 0.8;
        ctx.stroke();

        // Cork
        ctx.beginPath();
        ctx.rect(-2, -14, 4, 3);
        ctx.fillStyle = 'rgba(180,140,80,0.6)';
        ctx.fill();

        // Scroll visible inside
        ctx.beginPath();
        ctx.rect(-2, -6, 4, 10);
        ctx.fillStyle = 'rgba(240,220,170,0.3)';
        ctx.fill();

        // Glow
        var glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 30);
        glow.addColorStop(0, 'rgba(247,200,100,0.06)');
        glow.addColorStop(1, 'rgba(247,200,100,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, 30, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        // Quote text (unrotated, below bottle)
        if (b.quoteAlpha > 0.01) {
            ctx.save();
            ctx.globalAlpha = b.quoteAlpha;
            ctx.font = 'italic 11px "DM Sans", sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(247,200,100,0.85)';
            // Word wrap
            var words = b.quote.split(' ');
            var lines = [];
            var line = '';
            var maxW = Math.min(320, W * 0.45);
            for (var i = 0; i < words.length; i++) {
                var test = line + (line ? ' ' : '') + words[i];
                if (ctx.measureText(test).width > maxW && line) {
                    lines.push(line);
                    line = words[i];
                } else {
                    line = test;
                }
            }
            if (line) lines.push(line);

            // Text shadow bg
            var textY = b.y + 25;
            for (var j = 0; j < lines.length; j++) {
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillText(lines[j], b.x + 1, textY + j * 15 + 1);
                ctx.fillStyle = 'rgba(247,200,100,0.85)';
                ctx.fillText(lines[j], b.x, textY + j * 15);
            }
            // Attribution
            ctx.font = '9px "JetBrains Mono", monospace';
            ctx.fillStyle = 'rgba(247,200,100,0.4)';
            ctx.fillText('‚Äî Satoshi Nakamoto', b.x, textY + lines.length * 15 + 6);
            ctx.restore();
        }
    }

    // ‚îÄ‚îÄ 16) LIGHTNING STRIKE ‚Äî surface flash + bolt arcs into water ‚îÄ‚îÄ
    var lightning = null;

    function triggerLightning() {
        if (lightning) return;
        var strikeX = W * 0.15 + Math.random() * W * 0.7;
        // Generate fractal bolt segments
        var bolts = generateBolt(strikeX, 0, strikeX + (Math.random() - 0.5) * 100, H * 0.5, 6);
        // Add a branch or two
        var branchIdx = Math.floor(bolts.length * 0.3);
        if (bolts[branchIdx]) {
            var branch = generateBolt(
                bolts[branchIdx].x, bolts[branchIdx].y,
                bolts[branchIdx].x + (Math.random() - 0.5) * 120,
                bolts[branchIdx].y + 60 + Math.random() * 80, 3
            );
            bolts = bolts.concat(branch.map(function(p) { p.branch = true; return p; }));
        }

        lightning = {
            bolts: bolts,
            strikeX: strikeX,
            startTime: performance.now(),
            duration: 1200,
            flashPhase: 0,
        };

        // Scatter all fish from strike point
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped) continue;
            var dx = f.x - strikeX;
            var dy = f.y;
            var dist = Math.sqrt(dx * dx + dy * dy) || 1;
            var force = Math.max(0, 1 - dist / (W * 0.5)) * 5;
            f.vx += (dx / dist) * force;
            f.vy += (dy / dist) * force * 0.5;
        }

        feedInfo('<span style="color:#fde68a;">‚ö° Lightning strikes the surface!</span>');
    }

    function generateBolt(x1, y1, x2, y2, detail) {
        if (detail <= 0) return [{ x: x1, y: y1 }, { x: x2, y: y2 }];
        var midX = (x1 + x2) / 2 + (Math.random() - 0.5) * (y2 - y1) * 0.4;
        var midY = (y1 + y2) / 2 + (Math.random() - 0.5) * 20;
        var left = generateBolt(x1, y1, midX, midY, detail - 1);
        var right = generateBolt(midX, midY, x2, y2, detail - 1);
        return left.concat(right.slice(1));
    }

    function updateLightning(now, dt) {
        if (!lightning) return;
        var elapsed = now - lightning.startTime;
        if (elapsed > lightning.duration) { lightning = null; return; }
        lightning.flashPhase = elapsed / lightning.duration;
    }

    function drawLightning(now) {
        if (!lightning) return;
        var l = lightning;
        var t = l.flashPhase;

        // Flash ‚Äî bright white overlay at start
        var flashAlpha = t < 0.08 ? 0.3 : (t < 0.15 ? 0.05 : 0);
        // Second flash
        if (t > 0.2 && t < 0.25) flashAlpha = 0.1;
        if (flashAlpha > 0) {
            ctx.fillStyle = 'rgba(200,220,255,' + flashAlpha.toFixed(3) + ')';
            ctx.fillRect(0, 0, W, H);
        }

        // Bolt visibility ‚Äî flickers
        var boltAlpha = 0;
        if (t < 0.1) boltAlpha = 0.9;
        else if (t < 0.15) boltAlpha = 0.1;
        else if (t < 0.25) boltAlpha = 0.7;
        else if (t < 0.35) boltAlpha = 0.05;
        else if (t < 0.45) boltAlpha = 0.4;
        else boltAlpha = Math.max(0, 0.3 * (1 - (t - 0.45) / 0.55));

        if (boltAlpha < 0.01) return;

        // Draw bolt segments
        ctx.save();
        ctx.globalAlpha = boltAlpha;

        // Wide glow
        ctx.beginPath();
        ctx.moveTo(l.bolts[0].x, l.bolts[0].y);
        for (var i = 1; i < l.bolts.length; i++) {
            if (l.bolts[i].branch && !l.bolts[i - 1].branch) {
                ctx.moveTo(l.bolts[i].x, l.bolts[i].y);
            } else {
                ctx.lineTo(l.bolts[i].x, l.bolts[i].y);
            }
        }
        ctx.strokeStyle = 'rgba(150,180,255,0.3)';
        ctx.lineWidth = 8;
        ctx.stroke();

        // Medium glow
        ctx.beginPath();
        ctx.moveTo(l.bolts[0].x, l.bolts[0].y);
        for (var i = 1; i < l.bolts.length; i++) {
            if (l.bolts[i].branch && !l.bolts[i - 1].branch) {
                ctx.moveTo(l.bolts[i].x, l.bolts[i].y);
            } else {
                ctx.lineTo(l.bolts[i].x, l.bolts[i].y);
            }
        }
        ctx.strokeStyle = 'rgba(200,220,255,0.6)';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Core bright line
        ctx.beginPath();
        ctx.moveTo(l.bolts[0].x, l.bolts[0].y);
        for (var i = 1; i < l.bolts.length; i++) {
            if (l.bolts[i].branch && !l.bolts[i - 1].branch) {
                ctx.moveTo(l.bolts[i].x, l.bolts[i].y);
            } else {
                ctx.lineTo(l.bolts[i].x, l.bolts[i].y);
            }
        }
        ctx.strokeStyle = 'rgba(255,255,255,0.95)';
        ctx.lineWidth = 1.2;
        ctx.stroke();

        // Strike point glow on water surface
        var surfGlow = ctx.createRadialGradient(l.strikeX, 5, 0, l.strikeX, 5, 100);
        surfGlow.addColorStop(0, 'rgba(200,220,255,0.15)');
        surfGlow.addColorStop(1, 'rgba(200,220,255,0)');
        ctx.fillStyle = surfGlow;
        ctx.beginPath();
        ctx.arc(l.strikeX, 5, 100, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ‚îÄ‚îÄ 17) SEA TURTLE ‚Äî gentle giant with slipstream drafting ‚îÄ‚îÄ
    var seaTurtle = null;

    function triggerSeaTurtle() {
        if (seaTurtle) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        seaTurtle = {
            x: dir > 0 ? -50 : W + 50,
            y: H * 0.25 + Math.random() * H * 0.3,
            dir: dir,
            size: 55 + Math.random() * 20,
            speed: 0.6 + Math.random() * 0.25,
            flipperPhase: 0,
            flipperSpeed: 0.06,
            headBob: 0,
            startTime: performance.now(),
            alpha: 0,
        };
        feedInfo('<span style="color:#4AEABC;">üê¢ A sea turtle glides through peacefully‚Ä¶</span>');
    }

    function updateSeaTurtle(now, dt) {
        if (!seaTurtle) return;
        var t = seaTurtle;
        var elapsed = now - t.startTime;

        t.flipperPhase += t.flipperSpeed * dt;
        t.headBob = Math.sin(now * 0.0015) * 2;
        t.x += t.dir * t.speed * dt;
        t.y += Math.sin(now * 0.0008) * 0.12 * dt;

        // Fade in/out
        if (elapsed < 1200) t.alpha = Math.min(1, elapsed / 1200);
        if ((t.dir > 0 && t.x > W + 60) || (t.dir < 0 && t.x < -60)) {
            t.alpha -= 0.015 * dt;
        }
        if (t.alpha <= 0) { seaTurtle = null; return; }

        // Slipstream ‚Äî fish behind turtle get pulled along
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            var dx = f.x - t.x;
            var dy = f.y - t.y;
            var dist = Math.sqrt(dx * dx + dy * dy);

            // Draft zone: behind the turtle, within wake cone
            var behind = -t.dir * dx;
            if (behind > 10 && behind < 180 && Math.abs(dy) < 50 + behind * 0.3) {
                var draftForce = (1 - behind / 180) * 0.025 * dt;
                f.vx += t.dir * draftForce * 2;
                f.vy += (t.y - f.y) * 0.002 * dt;
                f.tailSpeed = Math.max(f.tailSpeed, 2);
            }

            // Gentle push away from body
            if (dist < t.size * 1.2 && dist > 0) {
                f.vx += (dx / dist) * 0.04 * dt;
                f.vy += (dy / dist) * 0.02 * dt;
            }
        }
    }

    function drawSeaTurtle(now) {
        if (!seaTurtle) return;
        var t = seaTurtle;
        var s = t.size;
        var flipCycle = t.flipperPhase;
        // Power stroke (down) is fast, recovery stroke (up) is slow ‚Äî like real turtles
        var flipAngle = Math.sin(flipCycle);
        var flipPower = flipAngle > 0 ? flipAngle * 1.2 : flipAngle * 0.6;

        ctx.save();
        ctx.globalAlpha = Math.max(0, t.alpha);
        ctx.translate(t.x, t.y);
        if (t.dir < 0) ctx.scale(-1, 1);

        // Body bob ‚Äî slight vertical oscillation synced to flipper strokes
        var bodyBob = Math.sin(flipCycle) * 1.5;
        ctx.translate(0, bodyBob);

        // Wake lines behind turtle
        ctx.strokeStyle = 'rgba(74,234,188,0.1)';
        ctx.lineWidth = 1.5;
        for (var w = 0; w < 4; w++) {
            ctx.beginPath();
            var wy = (w - 1.5) * 14;
            ctx.moveTo(-s * 0.5, wy);
            ctx.bezierCurveTo(-s * 1.2, wy + Math.sin(now * 0.002 + w) * 6,
                              -s * 2, wy + Math.sin(now * 0.0015 + w) * 10,
                              -s * 3, wy);
            ctx.stroke();
        }

        // Front flippers ‚Äî drawn BEHIND shell (lower layer)
        for (var side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(s * 0.15, side * s * 0.25);
            // Big sweeping rotation ‚Äî power stroke down, recovery up
            var flapAngle = side * (flipPower * 0.7 - 0.1);
            ctx.rotate(flapAngle);
            ctx.beginPath();
            // Elongated paddle shape
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(s * 0.15, side * s * 0.04,
                              s * 0.3, side * s * 0.06,
                              s * 0.42, side * s * 0.02);
            ctx.bezierCurveTo(s * 0.35, -side * s * 0.02,
                              s * 0.15, -side * s * 0.03,
                              0, 0);
            ctx.fillStyle = 'rgba(85,150,70,0.8)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(60,120,50,0.4)';
            ctx.lineWidth = 0.5;
            ctx.stroke();
            ctx.restore();
        }

        // Shell (carapace) ‚Äî large dome
        ctx.beginPath();
        ctx.ellipse(0, 0, s * 0.42, s * 0.32, 0, 0, Math.PI * 2);
        var shellGrad = ctx.createRadialGradient(-s * 0.08, -s * 0.06, s * 0.03, 0, 0, s * 0.42);
        shellGrad.addColorStop(0, 'rgba(140,200,100,0.9)');
        shellGrad.addColorStop(0.4, 'rgba(100,165,70,0.85)');
        shellGrad.addColorStop(1, 'rgba(65,120,45,0.75)');
        ctx.fillStyle = shellGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(100,160,85,0.5)';
        ctx.lineWidth = 1.2;
        ctx.stroke();

        // Shell scute pattern
        for (var si = 0; si < 5; si++) {
            var sx = -s * 0.15 + si * s * 0.1;
            var sy = Math.sin(si * 1.3) * s * 0.06;
            ctx.beginPath();
            ctx.arc(sx, sy, s * 0.065, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(130,190,100,0.3)';
            ctx.lineWidth = 0.6;
            ctx.stroke();
        }

        // BC2 logo on shell center
        if (bc2Logo.complete && bc2Logo.naturalWidth > 0) {
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.15, 0, Math.PI * 2);
            ctx.clip();
            ctx.drawImage(bc2Logo, -s * 0.15, -s * 0.15, s * 0.3, s * 0.3);
            ctx.restore();
        }

        // Head ‚Äî extends forward with bob
        var headX = s * 0.45 + t.headBob * 0.3;
        var headY = t.headBob * 0.4;
        // Neck
        ctx.beginPath();
        ctx.moveTo(s * 0.35, -s * 0.06);
        ctx.quadraticCurveTo(s * 0.4, headY - 2, headX - s * 0.05, headY);
        ctx.moveTo(s * 0.35, s * 0.06);
        ctx.quadraticCurveTo(s * 0.4, headY + 2, headX - s * 0.05, headY);
        ctx.strokeStyle = 'rgba(80,140,65,0.65)';
        ctx.lineWidth = s * 0.08;
        ctx.stroke();
        // Head
        ctx.beginPath();
        ctx.ellipse(headX, headY, s * 0.11, s * 0.08, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(90,155,75,0.85)';
        ctx.fill();

        // Eye
        ctx.beginPath();
        ctx.arc(headX + s * 0.05, headY - s * 0.025, s * 0.02, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(15,15,15,0.8)';
        ctx.fill();
        // Eye highlight
        ctx.beginPath();
        ctx.arc(headX + s * 0.055, headY - s * 0.03, s * 0.008, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fill();

        // Rear flippers ‚Äî small paddle kicks
        for (var side = -1; side <= 1; side += 2) {
            ctx.save();
            ctx.translate(-s * 0.3, side * s * 0.2);
            ctx.rotate(side * (-flipAngle * 0.3 + 0.2));
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 0.12, s * 0.04, side * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(80,145,65,0.65)';
            ctx.fill();
            ctx.restore();
        }

        // Tiny tail
        ctx.beginPath();
        ctx.moveTo(-s * 0.38, 0);
        ctx.lineTo(-s * 0.45, Math.sin(now * 0.004) * 3);
        ctx.strokeStyle = 'rgba(80,145,65,0.55)';
        ctx.lineWidth = 2;
        ctx.stroke();

        // Gentle ambient glow
        var glow = ctx.createRadialGradient(0, 0, s * 0.1, 0, 0, s * 1.5);
        glow.addColorStop(0, 'rgba(74,234,188,0.08)');
        glow.addColorStop(0.5, 'rgba(74,234,188,0.03)');
        glow.addColorStop(1, 'rgba(74,234,188,0)');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(0, 0, s * 1.5, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    // ‚îÄ‚îÄ 18) ELECTRIC EEL ‚Äî zaps across, stuns fish ‚îÄ‚îÄ
    var electricEel = null;

    function triggerElectricEel() {
        if (electricEel) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        var yPos = H * 0.3 + Math.random() * H * 0.4;
        electricEel = {
            x: dir > 0 ? -60 : W + 60,
            y: yPos,
            dir: dir,
            size: 8,
            bodyLen: 100 + Math.random() * 40,
            speed: 2.5 + Math.random() * 1.5,
            segments: [],
            phase: 0, // 0=swimming, 1=charging, 2=ZAP, 3=exit
            startTime: performance.now(),
            zapTime: 0,
            wavePhase: 0,
            alpha: 0,
            stunned: [],
            sparkles: [],
        };
        // Build segment chain
        for (var i = 0; i < 20; i++) {
            electricEel.segments.push({ x: electricEel.x - dir * i * 6, y: yPos });
        }
        feedInfo('<span style="color:#fde68a;">‚ö° An electric eel slithers through the tank‚Ä¶</span>');
    }

    function updateElectricEel(now, dt) {
        if (!electricEel) return;
        var e = electricEel;
        var elapsed = now - e.startTime;
        e.wavePhase += 0.04 * dt;

        // Fade in
        if (elapsed < 1000) e.alpha = Math.min(1, elapsed / 1000);

        if (e.phase === 0) {
            // Swimming ‚Äî scan for densest fish cluster to target
            // Every ~30 frames, find the densest group nearby
            if (!e._scanTimer) e._scanTimer = 0;
            e._scanTimer -= dt;
            if (e._scanTimer <= 0) {
                e._scanTimer = 30;
                var bestX = null, bestY = null, bestCount = 0;

                // Sample grid points ahead of the eel
                for (var gx = 0; gx < 5; gx++) {
                    for (var gy = 0; gy < 3; gy++) {
                        var sx = e.x + e.dir * (60 + gx * 80);
                        var sy = H * 0.15 + gy * H * 0.25;
                        var count = 0;
                        for (var i = 0; i < fishes.length; i++) {
                            var f = fishes[i];
                            if (f.scooped || f.rbfEaten) continue;
                            var dx = f.x - sx;
                            var dy = f.y - sy;
                            if (dx * dx + dy * dy < 22500) count++; // 150px radius
                        }
                        if (count > bestCount) {
                            bestCount = count;
                            bestX = sx;
                            bestY = sy;
                        }
                    }
                }

                if (bestCount >= 3 && bestX !== null) {
                    e._targetX = bestX;
                    e._targetY = bestY;
                    e._targetCount = bestCount;
                } else {
                    e._targetX = null;
                    e._targetY = null;
                }
            }

            // Steer toward cluster if found
            if (e._targetX !== null) {
                var tdx = e._targetX - e.x;
                var tdy = e._targetY - e.y;
                var tdist = Math.sqrt(tdx * tdx + tdy * tdy) || 1;

                // Steer Y toward target cluster
                e.y += (tdy / tdist) * 0.8 * dt;
                // Move forward ‚Äî speed up slightly when locked on
                e.x += e.dir * e.speed * 1.1 * dt;

                // When close to cluster center, start charging
                if (Math.abs(tdx) < 80 && Math.abs(tdy) < 60 && e._targetCount >= 3) {
                    e.phase = 1;
                    e._chargeStart = now;
                    feedInfo('<span style="color:#fde68a;">‚ö° The eel locks onto a school of fish‚Ä¶</span>');
                }
            } else {
                // No good cluster found ‚Äî swim forward, bob gently
                e.x += e.dir * e.speed * dt;
                e.y += Math.sin(now * 0.002) * 0.2 * dt;
            }

            // Fallback: if crossed 70% of tank without finding a cluster, zap anyway
            var crossDist = e.dir > 0 ? e.x : W - e.x;
            if (crossDist > W * 0.7 && e.phase === 0) {
                e.phase = 1;
                e._chargeStart = now;
            }
        }

        if (e.phase === 1) {
            // Charging ‚Äî slow down, body flickers
            e.x += e.dir * e.speed * 0.3 * dt;
            var chargeT = (now - e._chargeStart) / 800;
            if (chargeT > 1) {
                e.phase = 2;
                e.zapTime = now;
                // ZAP ‚Äî stun nearby fish
                for (var i = 0; i < fishes.length; i++) {
                    var f = fishes[i];
                    if (f.scooped || f.rbfEaten) continue;
                    var dx = f.x - e.x;
                    var dy = f.y - e.y;
                    var dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 140) {
                        f._stunned = true;
                        f._stunnedUntil = now + 2000 + Math.random() * 1500;
                        f._preStunVx = f.vx;
                        f._preStunVy = f.vy;
                        f.vx = 0;
                        f.vy = 0.15 + Math.random() * 0.1; // drift down
                        e.stunned.push(f);
                    }
                }
                // Spawn zap sparkles
                for (var j = 0; j < 30; j++) {
                    var angle = Math.random() * Math.PI * 2;
                    var r = 20 + Math.random() * 120;
                    e.sparkles.push({
                        x: e.x + Math.cos(angle) * r,
                        y: e.y + Math.sin(angle) * r,
                        life: 1,
                        decay: 0.02 + Math.random() * 0.03,
                        size: 1 + Math.random() * 3,
                    });
                }
                feedInfo('<span style="color:#fde68a;">‚ö°‚ö° ZAP! Fish are stunned!</span>');
            }
        }

        if (e.phase === 2) {
            // Post-zap ‚Äî resume swimming after brief pause
            var zapElapsed = now - e.zapTime;
            if (zapElapsed > 600) {
                e.phase = 3;
            }
        }

        if (e.phase === 3) {
            // Exit
            e.x += e.dir * e.speed * 1.3 * dt;
            if ((e.dir > 0 && e.x > W + 100) || (e.dir < 0 && e.x < -100)) {
                e.alpha -= 0.02 * dt;
            }
            if (e.alpha <= 0) {
                // Unstun any remaining fish before eel disappears
                for (var k = 0; k < e.stunned.length; k++) {
                    var sf = e.stunned[k];
                    sf._stunned = false;
                    sf.vx = sf._preStunVx || (sf.baseVx || ((Math.random() > 0.5 ? 1 : -1) * 0.5));
                    sf.vy = (Math.random() - 0.5) * 0.3;
                    sf.tailSpeed = sf.baseTailSpeed || (3 + Math.abs(sf.vx) * 2);
                }
                electricEel = null;
                return;
            }
        }

        // Update segment chain (follow the head)
        if (e) {
            e.segments[0].x = e.x;
            e.segments[0].y = e.y;
            for (var i = 1; i < e.segments.length; i++) {
                var prev = e.segments[i - 1];
                var seg = e.segments[i];
                var dx = seg.x - prev.x;
                var dy = seg.y - prev.y;
                var dist = Math.sqrt(dx * dx + dy * dy) || 1;
                var targetDist = 6;
                seg.x = prev.x + (dx / dist) * targetDist;
                seg.y = prev.y + (dy / dist) * targetDist;
                // Sinusoidal wave along body
                seg.y += Math.sin(e.wavePhase + i * 0.5) * (1 + i * 0.3);
            }
        }

        // Unstun fish when timer expires
        if (e) {
            for (var k = e.stunned.length - 1; k >= 0; k--) {
                var sf = e.stunned[k];
                if (now > sf._stunnedUntil) {
                    sf._stunned = false;
                    sf.vx = sf._preStunVx || (sf.baseVx || ((Math.random() > 0.5 ? 1 : -1) * 0.5));
                    sf.vy = (Math.random() - 0.5) * 0.3;
                    sf.tailSpeed = sf.baseTailSpeed || (3 + Math.abs(sf.vx) * 2);
                    e.stunned.splice(k, 1);
                    spawnBubble(sf.x, sf.y, 0.8);
                }
            }
        }

        // Update sparkles
        if (e) {
            for (var m = e.sparkles.length - 1; m >= 0; m--) {
                var sp = e.sparkles[m];
                sp.life -= sp.decay;
                if (sp.life <= 0) e.sparkles.splice(m, 1);
            }
        }
    }

    function drawElectricEel(now) {
        if (!electricEel) return;
        var e = electricEel;
        ctx.save();
        ctx.globalAlpha = Math.max(0, e.alpha);

        var isCharging = e.phase === 1;
        var isZapping = e.phase === 2;

        // Draw body segments as connected chain
        for (var i = 0; i < e.segments.length - 1; i++) {
            var s1 = e.segments[i];
            var s2 = e.segments[i + 1];
            var t = i / e.segments.length;
            var thick = e.size * (1 - t * 0.5) * (0.8 + Math.sin(i * 0.3) * 0.2);

            ctx.beginPath();
            ctx.moveTo(s1.x, s1.y);
            ctx.lineTo(s2.x, s2.y);

            // Color shifts when charging/zapping
            if (isZapping) {
                var flicker = Math.random();
                ctx.strokeStyle = 'rgba(255,' + Math.round(220 + flicker * 35) + ',60,' + (0.8 - t * 0.3).toFixed(2) + ')';
            } else if (isCharging) {
                var pulse = Math.sin(now * 0.02 + i * 0.5) * 0.5 + 0.5;
                ctx.strokeStyle = 'rgba(' + Math.round(80 + pulse * 170) + ',' + Math.round(80 + pulse * 140) + ',40,' + (0.7 - t * 0.2).toFixed(2) + ')';
            } else {
                ctx.strokeStyle = 'rgba(80,90,50,' + (0.65 - t * 0.25).toFixed(2) + ')';
            }
            ctx.lineWidth = thick;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Yellow lateral line
            if (i > 2 && i < e.segments.length - 3) {
                ctx.beginPath();
                ctx.moveTo(s1.x, s1.y);
                ctx.lineTo(s2.x, s2.y);
                ctx.strokeStyle = 'rgba(240,200,60,' + (0.3 - t * 0.15).toFixed(2) + ')';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Head
        var head = e.segments[0];
        ctx.beginPath();
        ctx.arc(head.x + e.dir * 4, head.y, e.size * 0.7, 0, Math.PI * 2);
        ctx.fillStyle = isZapping ? 'rgba(255,240,80,0.8)' : 'rgba(70,80,45,0.7)';
        ctx.fill();

        // Eye
        ctx.beginPath();
        ctx.arc(head.x + e.dir * 7, head.y - 2, 2, 0, Math.PI * 2);
        ctx.fillStyle = isZapping ? 'rgba(255,255,255,0.9)' : 'rgba(200,180,40,0.8)';
        ctx.fill();

        // Zap electric field
        if (isZapping || (isCharging && (now - e._chargeStart) > 500)) {
            var zapIntensity = isZapping ? 0.4 : 0.15;
            var zapGlow = ctx.createRadialGradient(e.x, e.y, 10, e.x, e.y, 150);
            zapGlow.addColorStop(0, 'rgba(255,240,80,' + (zapIntensity * 0.3).toFixed(3) + ')');
            zapGlow.addColorStop(0.4, 'rgba(255,220,40,' + (zapIntensity * 0.1).toFixed(3) + ')');
            zapGlow.addColorStop(1, 'rgba(255,200,0,0)');
            ctx.fillStyle = zapGlow;
            ctx.beginPath();
            ctx.arc(e.x, e.y, 150, 0, Math.PI * 2);
            ctx.fill();

            // Mini lightning arcs from body
            if (isZapping) {
                for (var a = 0; a < 6; a++) {
                    var arcAngle = Math.random() * Math.PI * 2;
                    var arcLen = 30 + Math.random() * 60;
                    var ax = e.x + Math.cos(arcAngle) * 15;
                    var ay = e.y + Math.sin(arcAngle) * 10;
                    ctx.beginPath();
                    ctx.moveTo(ax, ay);
                    var segments = 3 + Math.floor(Math.random() * 3);
                    for (var as = 0; as < segments; as++) {
                        ax += Math.cos(arcAngle) * (arcLen / segments) + (Math.random() - 0.5) * 15;
                        ay += Math.sin(arcAngle) * (arcLen / segments) + (Math.random() - 0.5) * 15;
                        ctx.lineTo(ax, ay);
                    }
                    ctx.strokeStyle = 'rgba(255,255,200,' + (0.3 + Math.random() * 0.4).toFixed(2) + ')';
                    ctx.lineWidth = 0.8;
                    ctx.stroke();
                }
            }
        }

        // Sparkles
        for (var s = 0; s < e.sparkles.length; s++) {
            var sp = e.sparkles[s];
            ctx.beginPath();
            ctx.arc(sp.x, sp.y, sp.size * sp.life, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,240,80,' + (sp.life * 0.6).toFixed(3) + ')';
            ctx.fill();
        }

        // Draw stunned indicators on affected fish
        for (var sf = 0; sf < e.stunned.length; sf++) {
            var stunFish = e.stunned[sf];
            if (!stunFish.alive || stunFish.scooped) continue;
            // Tiny dizzy stars
            var starPhase = now * 0.005 + sf;
            for (var st = 0; st < 3; st++) {
                var sa = starPhase + st * (Math.PI * 2 / 3);
                var sx = stunFish.x + Math.cos(sa) * stunFish.size * 1.2;
                var sy = stunFish.y - stunFish.size * 0.8 + Math.sin(sa) * 3;
                ctx.font = Math.round(stunFish.size * 0.4) + 'px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255,240,80,0.5)';
                ctx.fillText('‚ö°', sx, sy);
            }
        }

        ctx.restore();
    }

    // ‚îÄ‚îÄ 19) MANTA RAY ‚Äî massive overhead shadow ‚îÄ‚îÄ
    var mantaRay = null;

    function triggerMantaRay() {
        if (mantaRay) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        mantaRay = {
            x: dir > 0 ? -120 : W + 120,
            y: H * 0.12 + Math.random() * H * 0.15,
            dir: dir,
            size: 140 + Math.random() * 60,
            speed: 0.7 + Math.random() * 0.3,
            wingPhase: 0,
            wingSpeed: 0.008,
            startTime: performance.now(),
            alpha: 0,
        };
        feedInfo('<span style="color:#94a3b8;">ü¶à A manta ray passes overhead‚Ä¶</span>');
    }

    function updateMantaRay(now, dt) {
        if (!mantaRay) return;
        var m = mantaRay;
        var elapsed = now - m.startTime;

        m.wingPhase += m.wingSpeed * dt;
        m.x += m.dir * m.speed * dt;
        m.y += Math.sin(now * 0.0005) * 0.05 * dt;

        // Fade in/out ‚Äî much higher max alpha
        if (elapsed < 1500) m.alpha = Math.min(0.9, elapsed / 1500 * 0.9);
        if ((m.dir > 0 && m.x > W + 100) || (m.dir < 0 && m.x < -100)) {
            m.alpha -= 0.008 * dt;
        }
        if (m.alpha <= 0) { mantaRay = null; return; }

        // Shadow below ‚Äî scatter fish from the shadow zone
        var shadowY = m.y + H * 0.35; // shadow projects downward
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;
            var dx = f.x - m.x;
            var dy = f.y - shadowY;
            var absDx = Math.abs(dx);
            var absDy = Math.abs(dy);
            // Shadow zone is wide ellipse
            if (absDx < m.size * 0.7 && absDy < 40) {
                // Fish scatter away from shadow center
                var escapeForce = (1 - absDx / (m.size * 0.7)) * 0.04 * dt;
                f.vy += (dy > 0 ? 1 : -1) * escapeForce * 2;
                f.vx += (dx > 0 ? 1 : -1) * escapeForce;
            }
        }
    }

    function drawMantaRay(now) {
        if (!mantaRay) return;
        var m = mantaRay;
        var s = m.size;
        var wingBend = Math.sin(m.wingPhase);

        ctx.save();
        ctx.globalAlpha = Math.max(0, m.alpha);
        ctx.translate(m.x, m.y);
        if (m.dir < 0) ctx.scale(-1, 1);

        // Shadow on lower layer (projected down)
        var shadowY = H * 0.35;
        ctx.save();
        ctx.globalAlpha = m.alpha * 0.2;
        ctx.beginPath();
        ctx.ellipse(0, shadowY, s * 0.7, 30, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.9)';
        ctx.fill();
        ctx.restore();

        // Body ‚Äî diamond/kite shape with wing curve
        ctx.beginPath();
        // Nose
        ctx.moveTo(s * 0.45, 0);
        // Right wing (top when viewed from above)
        ctx.bezierCurveTo(
            s * 0.3, -s * 0.15,
            s * 0.1, -s * (0.42 + wingBend * 0.08),
            -s * 0.2, -s * (0.35 + wingBend * 0.12)
        );
        // Wing tip
        ctx.quadraticCurveTo(
            -s * 0.35, -s * (0.3 + wingBend * 0.15),
            -s * 0.45, -s * (0.15 + wingBend * 0.05)
        );
        // Tail
        ctx.lineTo(-s * 0.5, 0);
        // Left wing (bottom)
        ctx.lineTo(-s * 0.45, s * (0.15 - wingBend * 0.05));
        ctx.quadraticCurveTo(
            -s * 0.35, s * (0.3 - wingBend * 0.15),
            -s * 0.2, s * (0.35 - wingBend * 0.12)
        );
        ctx.bezierCurveTo(
            s * 0.1, s * (0.42 - wingBend * 0.08),
            s * 0.3, s * 0.15,
            s * 0.45, 0
        );
        ctx.closePath();

        var bodyGrad = ctx.createLinearGradient(0, -s * 0.4, 0, s * 0.4);
        bodyGrad.addColorStop(0, 'rgba(70,100,140,0.85)');
        bodyGrad.addColorStop(0.5, 'rgba(90,125,160,0.8)');
        bodyGrad.addColorStop(1, 'rgba(70,100,140,0.85)');
        ctx.fillStyle = bodyGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(120,170,210,0.35)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // White belly markings ‚Äî more visible
        ctx.beginPath();
        ctx.ellipse(s * 0.08, 0, s * 0.18, s * 0.1, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(200,220,240,0.25)';
        ctx.fill();
        // Gill slits
        for (var gi = 0; gi < 3; gi++) {
            ctx.beginPath();
            ctx.moveTo(s * 0.15 + gi * s * 0.06, -s * 0.04);
            ctx.lineTo(s * 0.15 + gi * s * 0.06, s * 0.04);
            ctx.strokeStyle = 'rgba(180,200,220,0.12)';
            ctx.lineWidth = 0.6;
            ctx.stroke();
        }

        // Eyes ‚Äî brighter
        ctx.beginPath();
        ctx.arc(s * 0.3, -s * 0.09, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180,210,230,0.5)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(s * 0.3, s * 0.09, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180,210,230,0.5)';
        ctx.fill();

        // Cephalic fins (horn-like lobes at front)
        for (var cf = -1; cf <= 1; cf += 2) {
            ctx.beginPath();
            ctx.moveTo(s * 0.38, cf * s * 0.04);
            ctx.quadraticCurveTo(s * 0.5, cf * s * 0.08, s * 0.48, cf * s * 0.14);
            ctx.strokeStyle = 'rgba(60,90,120,0.6)';
            ctx.lineWidth = 2.5;
            ctx.stroke();
        }

        // Tail ‚Äî long whip, more visible
        ctx.beginPath();
        ctx.moveTo(-s * 0.5, 0);
        ctx.quadraticCurveTo(-s * 0.7, Math.sin(now * 0.002) * 10, -s * 0.95, Math.sin(now * 0.003) * 15);
        ctx.strokeStyle = 'rgba(50,75,100,0.5)';
        ctx.lineWidth = 2.5;
        ctx.stroke();
        // Thin tail end
        ctx.beginPath();
        ctx.moveTo(-s * 0.95, Math.sin(now * 0.003) * 15);
        ctx.quadraticCurveTo(-s * 1.05, Math.sin(now * 0.004) * 12, -s * 1.15, Math.sin(now * 0.005) * 8);
        ctx.strokeStyle = 'rgba(50,75,100,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Bioluminescent edge glow ‚Äî makes manta visible against deep water
        ctx.shadowColor = 'rgba(74,234,188,0.3)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.ellipse(0, 0, s * 0.45, s * 0.35, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(74,234,188,' + (0.08 + Math.sin(now * 0.001) * 0.04).toFixed(3) + ')';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;

        ctx.restore();
    }

    // ‚îÄ‚îÄ 20) HERMIT CRAB ‚Äî scuttles along seabed, sits on treasure ‚îÄ‚îÄ
    var hermitCrab = null;

    function triggerHermitCrab() {
        if (hermitCrab) return;
        var dir = Math.random() > 0.5 ? 1 : -1;
        hermitCrab = {
            x: dir > 0 ? -20 : W + 20,
            y: H - 18,
            dir: dir,
            size: 8 + Math.random() * 5,
            speed: 0.15 + Math.random() * 0.15,
            legPhase: 0,
            legSpeed: 0.06,
            phase: 0, // 0=scuttling, 1=investigating, 2=sitting, 3=leaving
            startTime: performance.now(),
            alpha: 0,
            eyePhase: 0,
            pauseTimer: 0,
            pauseDuration: 0,
        };
        feedInfo('<span style="color:#d4a574;">ü¶Ä A hermit crab scuttles along the seabed</span>');
    }

    function updateHermitCrab(now, dt) {
        if (!hermitCrab) return;
        var c = hermitCrab;
        var elapsed = now - c.startTime;
        c.legPhase += c.legSpeed * dt;
        c.eyePhase += 0.02 * dt;

        // Fade in
        if (elapsed < 1000) c.alpha = Math.min(1, elapsed / 1000);

        if (c.phase === 0) {
            // Scuttling ‚Äî move with occasional pauses
            if (c.pauseTimer > 0) {
                c.pauseTimer -= dt;
                c.legSpeed = 0.01; // barely moving legs
            } else {
                c.x += c.dir * c.speed * dt;
                c.legSpeed = 0.06;

                // Random pauses to look around
                if (Math.random() < 0.003) {
                    c.pauseTimer = 40 + Math.random() * 80;
                }
            }

            // Check for treasure coin ‚Äî if nearby, investigate
            if (treasure && treasure.phase >= 1) {
                var dx = treasure.x - c.x;
                if (Math.abs(dx) < 80) {
                    c.phase = 1;
                    c.dir = dx > 0 ? 1 : -1;
                    c.speed = 0.25; // hurry toward it
                }
            }

            // Exit if walked across tank
            if ((c.dir > 0 && c.x > W + 30) || (c.dir < 0 && c.x < -30)) {
                c.alpha -= 0.01 * dt;
                if (c.alpha <= 0) { hermitCrab = null; return; }
            }
        }

        if (c.phase === 1) {
            // Investigating ‚Äî walk toward treasure
            if (treasure) {
                var dx = treasure.x - c.x;
                c.dir = dx > 0 ? 1 : -1;
                c.x += c.dir * c.speed * dt;

                if (Math.abs(dx) < 5) {
                    c.phase = 2;
                    c._sitStart = now;
                    c.legSpeed = 0.01;
                    feedInfo('<span style="color:#d4a574;">ü¶Ä The hermit crab claims the treasure!</span>');
                }
            } else {
                // Treasure gone, go back to scuttling
                c.phase = 0;
                c.speed = 0.15 + Math.random() * 0.15;
            }
        }

        if (c.phase === 2) {
            // Sitting on treasure ‚Äî sway legs happily
            c.legSpeed = 0.03;
            c.y = H - 18 + Math.sin(now * 0.003) * 0.5;

            // Sit for a while
            if (now - c._sitStart > 8000 + Math.random() * 5000 || !treasure) {
                c.phase = 3;
                c.dir = Math.random() > 0.5 ? 1 : -1;
                c.speed = 0.12;
                c.legSpeed = 0.06;
            }
        }

        if (c.phase === 3) {
            // Leaving
            c.x += c.dir * c.speed * dt;
            if ((c.dir > 0 && c.x > W + 30) || (c.dir < 0 && c.x < -30)) {
                c.alpha -= 0.02 * dt;
                if (c.alpha <= 0) { hermitCrab = null; }
            }
        }
    }

    function drawHermitCrab(now) {
        if (!hermitCrab) return;
        var c = hermitCrab;
        var s = c.size;
        var legWalk = Math.sin(c.legPhase);

        ctx.save();
        ctx.globalAlpha = Math.max(0, c.alpha);
        ctx.translate(c.x, c.y);
        if (c.dir < 0) ctx.scale(-1, 1);

        // Shell (spiral)
        ctx.beginPath();
        ctx.arc(-s * 0.3, -s * 0.5, s * 0.55, 0, Math.PI * 2);
        var shellGrad = ctx.createRadialGradient(-s * 0.2, -s * 0.6, s * 0.1, -s * 0.3, -s * 0.5, s * 0.55);
        shellGrad.addColorStop(0, 'rgba(210,170,120,0.7)');
        shellGrad.addColorStop(0.5, 'rgba(180,130,80,0.6)');
        shellGrad.addColorStop(1, 'rgba(140,100,60,0.5)');
        ctx.fillStyle = shellGrad;
        ctx.fill();
        ctx.strokeStyle = 'rgba(120,80,40,0.3)';
        ctx.lineWidth = 0.6;
        ctx.stroke();

        // Spiral pattern on shell
        ctx.beginPath();
        for (var sp = 0; sp < 8; sp++) {
            var sa = sp * 0.8;
            var sr = s * 0.1 + sp * s * 0.05;
            var sx = -s * 0.3 + Math.cos(sa) * sr;
            var sy = -s * 0.5 + Math.sin(sa) * sr;
            if (sp === 0) ctx.moveTo(sx, sy);
            else ctx.lineTo(sx, sy);
        }
        ctx.strokeStyle = 'rgba(160,110,60,0.25)';
        ctx.lineWidth = 0.5;
        ctx.stroke();

        // Body (peeks out from shell)
        ctx.beginPath();
        ctx.ellipse(s * 0.15, -s * 0.1, s * 0.35, s * 0.2, 0.1, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(180,90,70,0.55)';
        ctx.fill();

        // Legs ‚Äî 3 pairs, animated
        for (var leg = 0; leg < 3; leg++) {
            for (var side = -1; side <= 1; side += 2) {
                var legX = s * (-0.05 + leg * 0.15);
                var legY = side * s * 0.15;
                var legAngle = legWalk * 0.4 * (leg % 2 === 0 ? 1 : -1) + side * 0.3;
                ctx.beginPath();
                ctx.moveTo(legX, legY);
                ctx.lineTo(legX + Math.cos(legAngle + side * 0.8) * s * 0.35,
                           legY + Math.sin(legAngle + side * 0.8) * s * 0.25 + side * s * 0.15);
                ctx.strokeStyle = 'rgba(180,90,70,0.4)';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // Claws (front pair, bigger)
        for (var claw = -1; claw <= 1; claw += 2) {
            var clawX = s * 0.4;
            var clawY = claw * s * 0.12;
            var clawAngle = legWalk * 0.2 * claw;
            ctx.save();
            ctx.translate(clawX, clawY);
            ctx.rotate(clawAngle);
            // Arm
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.25, claw * s * 0.08);
            ctx.strokeStyle = 'rgba(200,100,80,0.5)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            // Pincer
            ctx.beginPath();
            ctx.moveTo(s * 0.25, claw * s * 0.08);
            ctx.lineTo(s * 0.35, claw * s * 0.02);
            ctx.lineTo(s * 0.25, claw * s * 0.08);
            ctx.lineTo(s * 0.33, claw * s * 0.15);
            ctx.strokeStyle = 'rgba(210,110,90,0.5)';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
        }

        // Eye stalks
        for (var eye = -1; eye <= 1; eye += 2) {
            var eyeSwivel = Math.sin(c.eyePhase + eye * 0.5) * 0.2;
            var eyeX = s * 0.35;
            var eyeY = eye * s * 0.08 + eyeSwivel * 3;
            // Stalk
            ctx.beginPath();
            ctx.moveTo(s * 0.2, eye * s * 0.05);
            ctx.quadraticCurveTo(s * 0.28, eyeY - eye * 3, eyeX, eyeY - eye * s * 0.15);
            ctx.strokeStyle = 'rgba(180,90,70,0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();
            // Eye ball
            ctx.beginPath();
            ctx.arc(eyeX, eyeY - eye * s * 0.15, s * 0.06, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(20,20,20,0.7)';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(eyeX + 0.5, eyeY - eye * s * 0.15 - 0.5, s * 0.02, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fill();
        }

        ctx.restore();
    }

    // ‚îÄ‚îÄ 21) TIDE CHANGE ‚Äî water level rises or drops ‚îÄ‚îÄ
    var tideChange = null;

    function triggerTideChange() {
        if (tideChange) return;
        var rising = Math.random() > 0.5;
        tideChange = {
            rising: rising,
            startTime: performance.now(),
            duration: 12000 + Math.random() * 8000,
            maxShift: 0.1 + Math.random() * 0.1, // 10-20% of tank height
            currentShift: 0, // 0 = normal, positive = water rose (fish compress down), negative = water dropped
        };
        feedInfo(rising
            ? '<span style="color:#38bdf8;">üåä The tide rises‚Ä¶</span>'
            : '<span style="color:#38bdf8;">üåä The tide recedes‚Ä¶</span>'
        );
    }

    function updateTideChange(now, dt) {
        if (!tideChange) return;
        var tc = tideChange;
        var elapsed = now - tc.startTime;
        var progress = elapsed / tc.duration;
        if (progress > 1) { tideChange = null; return; }

        // Ease in ‚Üí hold ‚Üí ease out
        var envelope;
        if (progress < 0.2) envelope = progress / 0.2;
        else if (progress > 0.75) envelope = (1 - progress) / 0.25;
        else envelope = 1;

        tc.currentShift = tc.maxShift * envelope * (tc.rising ? 1 : -1);

        // Push fish vertically
        var shift = tc.currentShift;
        var absShift = Math.abs(shift);
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped || f.rbfEaten) continue;

            if (shift > 0) {
                // Water rising ‚Äî compress fish downward, push away from surface
                var newSurface = H * shift * 1.5;
                if (f.y < newSurface + f.size * 2) {
                    f.vy += 0.06 * dt;
                }
                // General downward compression
                f.vy += shift * 0.01 * dt;
            } else {
                // Water dropping ‚Äî visible waterline drops, fish spread up
                var waterlineY = H * absShift * 2; // where the new waterline is visually

                // Fish below the middle get gently pushed upward to fill space
                if (f.y > H * 0.4) {
                    f.vy -= absShift * 0.04 * dt;
                }
                // Fish near the old surface (top) drift down slightly ‚Äî exposed area
                if (f.y < waterlineY + 20) {
                    f.vy += 0.04 * dt;
                }
                // Overall spread: gently push each fish toward center
                var centerY = H * 0.45;
                var pull = (centerY - f.y) * 0.0003 * absShift * dt;
                f.vy += pull;
            }
        }
    }

    function drawTideChange(now) {
        if (!tideChange) return;
        var tc = tideChange;
        var shift = tc.currentShift;
        if (Math.abs(shift) < 0.003) return;

        var absShift = Math.abs(shift);

        if (shift > 0) {
            // Water rising ‚Äî deeper blue overlay at top
            var waterRise = H * absShift * 2.5;
            var tideGrad = ctx.createLinearGradient(0, 0, 0, waterRise * 1.5);
            tideGrad.addColorStop(0, 'rgba(8,25,55,' + Math.min(0.5, absShift * 3).toFixed(3) + ')');
            tideGrad.addColorStop(0.6, 'rgba(8,25,55,' + Math.min(0.25, absShift * 1.5).toFixed(3) + ')');
            tideGrad.addColorStop(1, 'rgba(8,25,55,0)');
            ctx.fillStyle = tideGrad;
            ctx.fillRect(0, 0, W, waterRise * 1.5);

            // Caustic ripple at new water line
            ctx.strokeStyle = 'rgba(56,189,248,' + Math.min(0.3, absShift * 2).toFixed(3) + ')';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (var x = 0; x < W; x += 4) {
                var wy = waterRise * 0.4 + Math.sin(now * 0.003 + x * 0.03) * 3;
                if (x === 0) ctx.moveTo(x, wy);
                else ctx.lineTo(x, wy);
            }
            ctx.stroke();
        } else {
            // Water dropping ‚Äî exposed tank wall above new waterline
            var waterlineY = H * absShift * 2.5;

            // Exposed zone: LIGHTER gray to contrast the dark ocean
            var wallGrad = ctx.createLinearGradient(0, 0, 0, waterlineY + 10);
            wallGrad.addColorStop(0, 'rgba(30,45,65,' + Math.min(0.7, absShift * 5).toFixed(3) + ')');
            wallGrad.addColorStop(0.5, 'rgba(25,38,55,' + Math.min(0.5, absShift * 3.5).toFixed(3) + ')');
            wallGrad.addColorStop(0.85, 'rgba(18,30,45,' + Math.min(0.3, absShift * 2).toFixed(3) + ')');
            wallGrad.addColorStop(1, 'rgba(18,30,45,0)');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(0, 0, W, waterlineY + 10);

            // Horizontal water stain lines on exposed wall
            for (var b = 0; b < 6; b++) {
                var by = waterlineY * (0.1 + b * 0.14);
                if (by > waterlineY) continue;
                var lineAlpha = Math.min(0.15, absShift * 1.5) * (0.4 + b * 0.12);
                ctx.strokeStyle = 'rgba(60,100,140,' + lineAlpha.toFixed(3) + ')';
                ctx.lineWidth = 0.6;
                ctx.beginPath();
                ctx.moveTo(0, by);
                ctx.lineTo(W, by);
                ctx.stroke();
            }

            // Bright waterline glow band
            var wlAlpha = Math.min(0.5, absShift * 3.5);
            var wlGlow = ctx.createLinearGradient(0, waterlineY - 8, 0, waterlineY + 12);
            wlGlow.addColorStop(0, 'rgba(56,189,248,0)');
            wlGlow.addColorStop(0.3, 'rgba(56,189,248,' + (wlAlpha * 0.15).toFixed(3) + ')');
            wlGlow.addColorStop(0.5, 'rgba(56,189,248,' + (wlAlpha * 0.25).toFixed(3) + ')');
            wlGlow.addColorStop(0.7, 'rgba(56,189,248,' + (wlAlpha * 0.1).toFixed(3) + ')');
            wlGlow.addColorStop(1, 'rgba(56,189,248,0)');
            ctx.fillStyle = wlGlow;
            ctx.fillRect(0, waterlineY - 8, W, 20);

            // Wavy waterline ripple
            ctx.strokeStyle = 'rgba(120,200,255,' + wlAlpha.toFixed(3) + ')';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (var x = 0; x < W; x += 3) {
                var wy = waterlineY + Math.sin(now * 0.004 + x * 0.025) * 2.5 + Math.sin(now * 0.007 + x * 0.05) * 1;
                if (x === 0) ctx.moveTo(x, wy);
                else ctx.lineTo(x, wy);
            }
            ctx.stroke();

            // Drip streaks from exposed zone
            for (var d = 0; d < 10; d++) {
                var dx = W * 0.04 + d * W * 0.095 + Math.sin(d * 2.7) * 12;
                var dripProgress = (Math.sin(now * 0.001 + d * 1.7) + 1) * 0.5;
                var dripLen = waterlineY * (0.2 + dripProgress * 0.6);
                var dripAlpha = Math.min(0.15, absShift * 1.5);
                ctx.strokeStyle = 'rgba(70,140,200,' + dripAlpha.toFixed(3) + ')';
                ctx.lineWidth = 0.8;
                ctx.beginPath();
                ctx.moveTo(dx, 3);
                ctx.quadraticCurveTo(
                    dx + Math.sin(now * 0.002 + d) * 4,
                    dripLen * 0.5,
                    dx + Math.sin(now * 0.003 + d * 0.7) * 3,
                    dripLen
                );
                ctx.stroke();

                // Drip droplet at end
                if (dripLen > 15) {
                    ctx.beginPath();
                    ctx.arc(dx + Math.sin(now * 0.003 + d * 0.7) * 3, dripLen, 1.8, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(70,140,200,' + (dripAlpha * 0.7).toFixed(3) + ')';
                    ctx.fill();
                }
            }
        }
    }
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FOOD PELLETS ‚Äî trickle from top, fish eat them
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var foodPellets = [];

    function dropFood() {
        var count = 12 + Math.floor(Math.random() * 10);
        for (var i = 0; i < count; i++) {
            foodPellets.push({
                x: W * 0.05 + Math.random() * W * 0.9,
                y: -5 - Math.random() * 30,
                vy: 0.3 + Math.random() * 0.4,
                vx: (Math.random() - 0.5) * 0.15,
                size: 2 + Math.random() * 2,
                wobblePhase: Math.random() * Math.PI * 2,
                wobbleSpeed: 0.02 + Math.random() * 0.02,
                life: 1,
                eaten: false,
                // Warm food colors
                hue: Math.random() < 0.5 ? (20 + Math.random() * 25) : (35 + Math.random() * 15),
                delay: i * 40 + Math.random() * 200, // stagger drop
                spawnTime: performance.now(),
            });
        }
        feedInfo('<span style="color:#fbbf24;">üêü Fish food sprinkled into the tank!</span>');
    }

    window._dropFood = dropFood;

    function updateFoodPellets(now, dt) {
        for (var i = foodPellets.length - 1; i >= 0; i--) {
            var p = foodPellets[i];

            // Stagger entry
            if (now - p.spawnTime < p.delay) continue;

            // Drift down with wobble
            p.wobblePhase += p.wobbleSpeed * dt;
            p.x += p.vx * dt + Math.sin(p.wobblePhase) * 0.15 * dt;
            p.y += p.vy * dt;

            // Slow down as it sinks (water resistance)
            p.vy *= 0.999;

            // Remove if hit bottom or faded
            if (p.y > H - 20 || p.eaten) {
                if (p.eaten) {
                    // Tiny satisfaction bubble
                    spawnBubble(p.x, p.y, 0.4);
                }
                foodPellets.splice(i, 1);
                continue;
            }

            // Check if any fish eats it
            for (var j = 0; j < fishes.length; j++) {
                var f = fishes[j];
                if (f.scooped || f.rbfEaten || f._stunned) continue;
                var dx = f.x - p.x;
                var dy = f.y - p.y;
                var eatDist = f.size * 0.8;
                if (dx * dx + dy * dy < eatDist * eatDist) {
                    p.eaten = true;
                    // Small feeding animation ‚Äî fish wiggles
                    f.tailSpeed = Math.max(f.tailSpeed, 6);
                    break;
                }
            }
        }

        // Fish are attracted to nearby food
        if (foodPellets.length > 0) {
            for (var j = 0; j < fishes.length; j++) {
                var f = fishes[j];
                if (f.scooped || f.rbfEaten || f._stunned || f._scared || f._schooling) continue;

                // Find nearest pellet
                var nearestP = null;
                var nearestDist = 200; // attraction range
                for (var k = 0; k < foodPellets.length; k++) {
                    var fp = foodPellets[k];
                    if (fp.eaten || (performance.now() - fp.spawnTime < fp.delay)) continue;
                    var dx = fp.x - f.x;
                    var dy = fp.y - f.y;
                    var d = Math.sqrt(dx * dx + dy * dy);
                    if (d < nearestDist) {
                        nearestDist = d;
                        nearestP = fp;
                    }
                }

                if (nearestP) {
                    var fdx = nearestP.x - f.x;
                    var fdy = nearestP.y - f.y;
                    var fd = Math.sqrt(fdx * fdx + fdy * fdy) || 1;
                    // Stronger pull when closer
                    var pull = (1 - nearestDist / 200) * 0.04;
                    f.vx += (fdx / fd) * pull * dt;
                    f.vy += (fdy / fd) * pull * dt;
                    f.tailSpeed = Math.max(f.tailSpeed, 4.5);
                }
            }
        }
    }

    function drawFoodPellets(now) {
        for (var i = 0; i < foodPellets.length; i++) {
            var p = foodPellets[i];
            if (now - p.spawnTime < p.delay) continue;
            if (p.eaten) continue;

            var entryProgress = Math.min(1, (now - p.spawnTime - p.delay) / 300);

            ctx.save();
            ctx.globalAlpha = entryProgress * 0.9;

            // Pellet body
            var r = Math.floor(180 + Math.sin(p.hue * 0.1) * 40);
            var g = Math.floor(120 + Math.cos(p.hue * 0.15) * 30);
            var b = Math.floor(40 + Math.sin(p.hue * 0.05) * 20);
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = 'rgb(' + r + ',' + g + ',' + b + ')';
            ctx.fill();

            // Highlight
            ctx.beginPath();
            ctx.arc(p.x - p.size * 0.25, p.y - p.size * 0.25, p.size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,240,200,0.4)';
            ctx.fill();

            // Gentle glow in water
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',0.04)';
            ctx.fill();

            ctx.restore();
        }
    }

    function tickAmbientEvents(now) {
        // Don't fire events during whale passage
        if (whale) return;

        if (now > eventTimers.predatorChase.nextFire && !predator) {
            spawnPredatorChase();
            // Only push the timer out if spawn succeeded ‚Äî otherwise retry sooner
            if (predator) {
                scheduleNextFire('predatorChase');
            } else {
                eventTimers.predatorChase.nextFire = now + 5000; // retry in 5s
            }
        }
        if (now > eventTimers.bubbleVent.nextFire) {
            triggerBubbleVent();
            scheduleNextFire('bubbleVent');
        }
        if (now > eventTimers.biolumPulse.nextFire) {
            triggerBiolumPulse();
            scheduleNextFire('biolumPulse');
        }
        if (now > eventTimers.schooling.nextFire) {
            triggerSchooling();
            scheduleNextFire('schooling');
        }
        if (now > eventTimers.currentSweep.nextFire) {
            triggerCurrentSweep();
            scheduleNextFire('currentSweep');
        }
        if (now > eventTimers.anglerfish.nextFire && !anglerfish) {
            spawnAnglerfish();
            scheduleNextFire('anglerfish');
        }
        if (now > eventTimers.treasureDrop.nextFire && !treasure) {
            triggerTreasureDrop();
            scheduleNextFire('treasureDrop');
        }
        if (now > eventTimers.baitball.nextFire && !baitball) {
            triggerBaitball();
            scheduleNextFire('baitball');
        }
        if (now > eventTimers.aurora.nextFire && !aurora) {
            triggerAurora();
            scheduleNextFire('aurora');
        }
        if (now > eventTimers.krakenTentacle.nextFire && !kraken) {
            triggerKraken();
            scheduleNextFire('krakenTentacle');
        }
        if (now > eventTimers.satoshiGhost.nextFire && !satoshiGhost) {
            triggerSatoshiGhost();
            scheduleNextFire('satoshiGhost');
        }
        if (now > eventTimers.jellyfish.nextFire && !jellyfishEvent) {
            triggerJellyfish();
            scheduleNextFire('jellyfish');
        }
        if (now > eventTimers.seaquake.nextFire) {
            triggerSeaquake();
            scheduleNextFire('seaquake');
        }
        if (now > eventTimers.planktonBloom.nextFire && !planktonBloom) {
            triggerPlanktonBloom();
            scheduleNextFire('planktonBloom');
        }
        if (now > eventTimers.bottleMessage.nextFire && !bottleMsg) {
            triggerBottleMessage();
            scheduleNextFire('bottleMessage');
        }
        if (now > eventTimers.lightningStrike.nextFire) {
            triggerLightning();
            scheduleNextFire('lightningStrike');
        }
        if (now > eventTimers.seaTurtle.nextFire && !seaTurtle) {
            triggerSeaTurtle();
            scheduleNextFire('seaTurtle');
        }
        if (now > eventTimers.electricEel.nextFire && !electricEel) {
            triggerElectricEel();
            scheduleNextFire('electricEel');
        }
        if (now > eventTimers.mantaRay.nextFire && !mantaRay) {
            triggerMantaRay();
            scheduleNextFire('mantaRay');
        }
        if (now > eventTimers.hermitCrab.nextFire && !hermitCrab) {
            triggerHermitCrab();
            scheduleNextFire('hermitCrab');
        }
        if (now > eventTimers.tideChange.nextFire && !tideChange) {
            triggerTideChange();
            scheduleNextFire('tideChange');
        }
    }
    var mouseX = -999, mouseY = -999;
    var mouseInTank = false;
    var REPEL_RADIUS = 90;
    var REPEL_FORCE = 0.35;

    canvas.addEventListener('mousemove', function(e) {
        var rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
        mouseInTank = true;
    });
    canvas.addEventListener('mouseleave', function() {
        mouseInTank = false;
        mouseX = -999;
        mouseY = -999;
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  UPDATE LOOP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var lastTime = 0;
    var frameBubbleTimer = 0;

    function update(now) {
        var dt = lastTime ? (now - lastTime) / 16.67 : 1;
        lastTime = now;
        if (dt > 3) dt = 3; // cap lag spikes

        for (var i = fishes.length - 1; i >= 0; i--) {
            var f = fishes[i];

            // Remove fully dead fish
            if (!f.alive) { fishes.splice(i, 1); continue; }
            if (f.scooped) continue;
            if (f.rbfEaten) {
                // Still animate phases for the shrink render
                f.tailPhase += f.tailSpeed * 0.02 * dt;
                f.glowPhase += 0.015 * dt;
                // Remove after eat animation completes
                if ((now - f.rbfEatTime) / 1000 > 0.7) {
                    unregisterFish(f);
                    fishes.splice(i, 1);
                }
                continue;
            }

            f.age += dt;
            f.tailPhase += f.tailSpeed * 0.02 * dt;
            f.glowPhase += 0.015 * dt;

            // RBF hunters are steered by updateRbfHunters, skip wander
            if (f.isRbf && f.huntPhase < 2) continue;

            // Stunned fish drift down slowly, skip wander
            if (f._stunned) {
                // Safety net ‚Äî force unstun if timer expired (eel may have left)
                if (f._stunnedUntil && now > f._stunnedUntil) {
                    f._stunned = false;
                    f.vx = f._preStunVx || (f.baseVx || f.dir * 0.5);
                    f.vy = (Math.random() - 0.5) * 0.3;
                    f.tailSpeed = f.baseTailSpeed || 4;
                } else {
                    f.x += f.vx * dt;
                    f.y += f.vy * dt;
                    f.vy = Math.min(f.vy + 0.005 * dt, 0.3);
                    f.vx *= 0.99;
                    f.tailSpeed = 1;
                    // Boundary
                    if (f.y > H - 22 - f.size) { f.y = H - 22 - f.size; f.vy = 0; }
                    continue;
                }
            }

            // Schooling fish ‚Äî steered by updateSchooling, skip wander entirely
            if (f._schooling) {
                // Heavy velocity damping ‚Äî prevents runaway acceleration
                f.vx *= 0.96;
                f.vy *= 0.96;
                // Hard speed cap
                var spd = Math.sqrt(f.vx * f.vx + f.vy * f.vy);
                if (spd > 1.5) {
                    f.vx *= 1.5 / spd;
                    f.vy *= 1.5 / spd;
                }
                f.x += f.vx * dt;
                f.y += f.vy * dt;
                // Smooth direction tracking
                if (Math.abs(f.vx) > 0.15) f.dir = f.vx > 0 ? 1 : -1;
                var targetTilt = Math.atan2(f.vy, Math.abs(f.vx) + 0.3);
                targetTilt = Math.max(-0.7, Math.min(0.7, targetTilt));
                f.tilt += (targetTilt - f.tilt) * 0.06 * dt;
                // Boundary
                if (f.y < f.size) { f.y = f.size; f.vy = Math.abs(f.vy) * 0.3; }
                if (f.y > H - 22 - f.size) { f.y = H - 22 - f.size; f.vy = -Math.abs(f.vy) * 0.3; }
                if (f.x < -50) f.x = W + 50;
                if (f.x > W + 50) f.x = -50;
                continue;
            }

            // Wander behavior
            f.wanderTimer -= dt;
            if (f.wanderTimer <= 0) {
                f.wanderTimer = 80 + Math.random() * 200;
                f.wanderAngle += (Math.random() - 0.5) * 1.2;
                // Occasionally change Y target
                if (Math.random() < 0.3) {
                    f.yTarget = f.y + (Math.random() - 0.5) * H * 0.25;
                    f.yTarget = Math.max(H * 0.05, Math.min(H * 0.9, f.yTarget));
                }
            }

            // Steering toward yTarget
            var yDiff = f.yTarget - f.y;
            f.vy += yDiff * 0.0003 * dt;
            f.vy *= 0.98; // damping

            // ‚îÄ‚îÄ ORGANIC FLOCKING (boids-lite) ‚îÄ‚îÄ
            // Fish naturally cluster with similar-sized nearby fish
            // then break off after a while
            if (!f._flockCooldown) f._flockCooldown = 0;
            if (!f._flockTime) f._flockTime = 0;
            if (f._flockCooldown > 0) {
                f._flockCooldown -= dt;
            } else {
                var alignX = 0, alignY = 0;
                var cohX = 0, cohY = 0;
                var sepX = 0, sepY = 0;
                var neighbors = 0;

                // Only check subset for performance (every 3rd fish)
                for (var ni = i % 3; ni < fishes.length; ni += 3) {
                    var n = fishes[ni];
                    if (n === f || n.scooped || n.rbfEaten || n._stunned || n._scared) continue;
                    var ndx = n.x - f.x;
                    var ndy = n.y - f.y;
                    var nd2 = ndx * ndx + ndy * ndy;

                    // Only flock with similar-sized fish within range
                    var sizeRatio = f.size / (n.size || 1);
                    if (sizeRatio < 0.5 || sizeRatio > 2) continue;

                    if (nd2 < 8100) { // 90px radius
                        var nd = Math.sqrt(nd2) || 1;
                        neighbors++;

                        // Alignment ‚Äî match velocity
                        alignX += n.vx;
                        alignY += n.vy;

                        // Cohesion ‚Äî steer toward center of neighbors
                        cohX += n.x;
                        cohY += n.y;

                        // Separation ‚Äî avoid crowding
                        if (nd < 30) {
                            sepX -= (ndx / nd) * (30 - nd) * 0.01;
                            sepY -= (ndy / nd) * (30 - nd) * 0.01;
                        }
                    }
                }

                if (neighbors >= 2) {
                    f._flockTime += dt;
                    var flockStr = 0.003; // gentle

                    // Alignment
                    alignX /= neighbors;
                    alignY /= neighbors;
                    f.vx += (alignX - f.vx) * flockStr * dt;
                    f.vy += (alignY - f.vy) * flockStr * 0.5 * dt;

                    // Cohesion
                    cohX = cohX / neighbors - f.x;
                    cohY = cohY / neighbors - f.y;
                    f.vx += cohX * flockStr * 0.3 * dt;
                    f.vy += cohY * flockStr * 0.3 * dt;

                    // Separation
                    f.vx += sepX * dt;
                    f.vy += sepY * dt;

                    // Natural breakoff ‚Äî chance increases the longer they flock
                    // Fish get "bored" of the group
                    var breakChance = 0;
                    if (f._flockTime > 300) breakChance = 0.0003;    // after ~5s
                    if (f._flockTime > 600) breakChance = 0.001;     // after ~10s
                    if (f._flockTime > 1000) breakChance = 0.003;    // after ~16s

                    if (Math.random() < breakChance) {
                        // Break off ‚Äî dart away with a small burst
                        f._flockCooldown = 200 + Math.random() * 300; // solo time
                        f._flockTime = 0;
                        f.vy += (Math.random() - 0.5) * 1.5;
                        f.wanderAngle += (Math.random() - 0.5) * 2;
                        // New Y target away from the group
                        f.yTarget = f.y + (Math.random() > 0.5 ? 1 : -1) * (H * 0.1 + Math.random() * H * 0.15);
                        f.yTarget = Math.max(H * 0.05, Math.min(H * 0.9, f.yTarget));
                        spawnBubble(f.x, f.y, 0.3);
                    }
                } else {
                    // Not near enough neighbors ‚Äî decay flock time
                    f._flockTime = Math.max(0, f._flockTime - dt * 0.5);
                }
            }

            // Gradually restore speed to base after event boosts/drains
            // Skip if fish is being chased by predator (needs to flee fast)
            if (f.baseSpeed && !f._scared) {
                var curSpeed = Math.abs(f.vx);
                var baseSpd = f.baseSpeed;
                var targetVx = f.dir * baseSpd;

                // If boosted above base, gently pull back down
                if (curSpeed > baseSpd * 1.3) {
                    f.vx += (targetVx - f.vx) * 0.015 * dt;
                }
                // If drained below base, gently push back up
                else if (curSpeed < baseSpd * 0.5) {
                    f.vx += (targetVx - f.vx) * 0.008 * dt;
                }

                // Restore tailSpeed
                f.tailSpeed += (f.baseTailSpeed - f.tailSpeed) * 0.01 * dt;
            }

            // Move
            f.x += f.vx * dt;
            f.y += f.vy * dt;

            // Smooth direction tracking ‚Äî update dir from velocity
            if (Math.abs(f.vx) > 0.15) {
                f.dir = f.vx > 0 ? 1 : -1;
            }

            // Smooth tilt from velocity vector ‚Äî nose follows motion
            var targetTilt = Math.atan2(f.vy, Math.abs(f.vx) + 0.3);
            // Clamp max tilt to prevent fish going fully vertical
            targetTilt = Math.max(-0.7, Math.min(0.7, targetTilt));
            f.tilt += (targetTilt - f.tilt) * 0.06 * dt;

            // Thermal vent updraft push
            if (activeVent) {
                var ventDx = f.x - activeVent.x;
                var ventDy = f.y - activeVent.y;
                var ventDist = Math.sqrt(ventDx * ventDx + ventDy * ventDy);
                if (ventDist < 120) {
                    var ventForce = (1 - ventDist / 120) * activeVent.strength;
                    f.vy -= ventForce * 0.06 * dt; // push upward
                    f.vx += ventDx * 0.001 * dt; // slight outward spread
                }
            }

            // Boundary: wrap horizontally
            if (f.dir > 0 && f.x > W + f.size * 2) {
                f.x = -f.size * 2;
            } else if (f.dir < 0 && f.x < -f.size * 2) {
                f.x = W + f.size * 2;
            }

            // Vertical bounds
            if (f.y < f.size) { f.y = f.size; f.vy = Math.abs(f.vy) * 0.5; }
            if (f.y > H - 22 - f.size) { f.y = H - 22 - f.size; f.vy = -Math.abs(f.vy) * 0.5; }

            // Occasional bubbles from fast fish
            frameBubbleTimer += dt;
            if (frameBubbleTimer > 8 && Math.abs(f.vx) > 1.5 && Math.random() < 0.02) {
                spawnBubble(f.x - f.dir * f.size * 0.3, f.y, 0.5);
            }
        }
        if (frameBubbleTimer > 8) frameBubbleTimer = 0;

        updateRbfHunters(dt);
        updateBubbles();
        updateSediments();
        updateFoodPellets(now, dt);
        updateBoat(now, dt);
        updateWhale(now);

        // Ambient events
        tickAmbientEvents(now);
        updatePredatorChase(now, dt);
        updateBiolumPulse(now);
        updateSchooling(now, dt);
        updateCurrentSweep(now, dt);
        updateAnglerfish(now, dt);
        updateTreasureDrop(now, dt);
        updateBaitball(now, dt);
        updateKraken(now, dt);
        updateSatoshiGhost(now, dt);
        updateJellyfish(now, dt);
        updateSeaquake(now, dt);
        updatePlanktonBloom(now, dt);
        updateBottleMessage(now, dt);
        updateLightning(now, dt);
        updateSeaTurtle(now, dt);
        updateElectricEel(now, dt);
        updateMantaRay(now, dt);
        updateHermitCrab(now, dt);
        updateTideChange(now, dt);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  MAIN RENDER LOOP
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Separate update and draw into one RAF
    function mainLoop(now) {
        update(now);
        ctx.clearRect(0, 0, W, H);

        // Seaquake ‚Äî shake the entire frame
        var quakeOx = 0, quakeOy = 0;
        if (seaquake) {
            var qProg = (now - seaquake.startTime) / seaquake.duration;
            var qShake = seaquake.intensity * Math.max(0, 1 - qProg);
            quakeOx = (Math.random() - 0.5) * qShake * 10;
            quakeOy = (Math.random() - 0.5) * qShake * 6;
            ctx.save();
            ctx.translate(quakeOx, quakeOy);
        }

        // Layer 1: God rays from surface
        drawGodRays(now);

        // Layer 1.5: Aurora (behind everything, near surface)
        drawAurora(now);

        // Layer 2: Depth fog atmosphere
        drawDepthFog();

        // Layer 3: Background bioluminescent orbs
        drawOrbs(now);

        // Layer 4: Kelp / seaweed silhouettes
        drawKelp(now);

        // Layer 5: Seabed with glow patches
        drawSeabed(now);

        // Layer 5.5: Plankton bloom (behind sediment and fish)
        drawPlanktonBloom(now);

        // Layer 6: Sediment dust (behind fish, in front of seabed)
        drawSediments();

        // Layer 6.05: Seabed structures (decorations fish explore)

        // Layer 1.5: Food pellets (behind fish)
        drawFoodPellets(now);

        // Layer 6.45: Surface debris (background ‚Äî fish swim in front)

        // Layer 6.1: Thermal vent heat shimmer
        if (activeVent) {
            var vx = activeVent.x;
            var vs = activeVent.strength;
            ctx.save();
            ctx.globalAlpha = vs * 0.35;
            // Rising heat column ‚Äî wavy gradient lines
            for (var vi = 0; vi < 5; vi++) {
                var lineX = vx + (vi - 2) * 12;
                var phase = performance.now() * 0.003 + vi * 1.5;
                ctx.beginPath();
                ctx.moveTo(lineX, H - 15);
                for (var vy2 = H - 20; vy2 > H * 0.15; vy2 -= 8) {
                    var waveX = lineX + Math.sin(phase + vy2 * 0.02) * (6 + (H - vy2) * 0.02);
                    ctx.lineTo(waveX, vy2);
                }
                var col_a = (1 - vi * 0.15) * 0.08;
                ctx.strokeStyle = 'rgba(247,147,26,' + col_a.toFixed(4) + ')';
                ctx.lineWidth = 1.5 - vi * 0.15;
                ctx.stroke();
            }
            // Base glow at vent source
            var ventGlow = ctx.createRadialGradient(vx, H - 10, 0, vx, H - 10, 50);
            ventGlow.addColorStop(0, 'rgba(247,147,26,0.12)');
            ventGlow.addColorStop(0.5, 'rgba(247,100,20,0.04)');
            ventGlow.addColorStop(1, 'rgba(247,100,20,0)');
            ctx.fillStyle = ventGlow;
            ctx.beginPath();
            ctx.arc(vx, H - 10, 50, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        // Layer 6.3: Treasure coin (on seabed level)
        drawTreasureDrop(now);

        // Layer 6.35: Hermit crab (on seabed)
        drawHermitCrab(now);


        // Layer 6.4: Bottle message
        drawBottleMessage(now);

        // Layer 6.5: Current sweep streaks (behind fish)
        drawCurrentSweep(now);

        // Layer 6.7: Bioluminescent pulse wave (behind fish)
        drawBiolumWave(now);

        // Layer 6.8: Baitball (behind normal fish, small fry)
        drawBaitball(now);

        // Layer 6.9: Surface debris ‚Äî background pieces (fish swim in front)

        // Layer 7: Fish (sorted small‚Üílarge for depth)
        var sorted = fishes.slice().sort(function(a, b) { return a.size - b.size; });
        for (var i = 0; i < sorted.length; i++) {
            drawFish(sorted[i], now);
        }

        // Layer 7.15: Electric eel (among fish)
        drawElectricEel(now);

        // Layer 7.2: Sea turtle (larger than fish)
        drawSeaTurtle(now);

        // Layer 7.25: Manta ray (overhead, above most creatures)
        drawMantaRay(now);

        // Layer 7.3: Jellyfish (among fish layer)
        drawJellyfish(now);

        // Layer 7.5: Predator (on top of fish)
        drawPredator(now);

        // Layer 7.6: Anglerfish (deep layer creature)
        drawAnglerfish(now);

        // Layer 7.7: Kraken tentacle
        drawKraken(now);

        // Layer 7.8: Satoshi's Ghost (top spectral layer)
        drawSatoshiGhost(now);

        // Layer 7.9: Surface debris ‚Äî foreground pieces (fish swim behind)

        // Layer 7.9: Surface debris (foreground ‚Äî fish swim behind)

        // Layer 8: Bubbles (foreground particles)
        drawBubbles();

        // Layer 8.5: Lightning bolt (foreground flash)
        drawLightning(now);

        // Layer 8.7: Seaquake overlay
        drawSeaquake(now);

        // Layer 8.8: Tide change overlay
        drawTideChange(now);

        // Layer 9: Whale (top of everything)
        drawWhale();

        // Layer 9.5: Boat (rides the surface)
        drawBoat(now);

        // Layer 10: Water surface ripple (very top)
        drawSurface(now);

        // Close seaquake transform
        if (seaquake) ctx.restore();

        requestAnimationFrame(mainLoop);
    }


    requestAnimationFrame(mainLoop);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  UI UPDATES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function updateFishCount() {
        var el = document.getElementById('fishCount');
        if (el) el.textContent = fishes.filter(function(f) { return !f.scooped; }).length;
    }

    function setStatus(state, text) {
        var dot = document.getElementById('statusDot');
        var txt = document.getElementById('statusText');
        dot.className = 'dot dot-' + state;
        txt.textContent = text;
    }

    function showBlockNotif(height, txCount) {
        var notif = document.getElementById('blockNotif');
        var title = document.getElementById('notifTitle');
        var detail = document.getElementById('notifDetail');
        title.textContent = 'Block #' + (height ? height.toLocaleString() : '?') + ' Mined!';
        detail.textContent = (txCount || '?') + ' transactions scooped from the pool';
        notif.classList.add('show');
        setTimeout(function() { notif.classList.remove('show'); }, 4000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  ACTIVITY FEED
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var feedContainer = document.getElementById('feedContainer');
    var feedMax = 50;
    var feedCount = 0;

    function feedTime() {
        var d = new Date();
        var h = d.getHours().toString().padStart(2, '0');
        var m = d.getMinutes().toString().padStart(2, '0');
        var s = d.getSeconds().toString().padStart(2, '0');
        return h + ':' + m + ':' + s;
    }

    function addFeedItem(type, html) {
        // Remove empty state
        var empty = feedContainer.querySelector('.feed-empty');
        if (empty) empty.remove();

        var item = document.createElement('div');
        item.className = 'feed-item';

        var iconClass = type === 'block' ? 'block' : type === 'tx' ? 'tx' : 'info';
        var iconEmoji = type === 'block' ? '‚õè' : type === 'tx' ? 'üêü' : '‚Ñπ';

        item.innerHTML =
            '<div class="feed-icon ' + iconClass + '">' + iconEmoji + '</div>' +
            '<div class="feed-text">' + html + '</div>' +
            '<div class="feed-time">' + feedTime() + '</div>';

        // Insert at top
        feedContainer.insertBefore(item, feedContainer.firstChild);
        feedCount++;

        // Trim old items
        while (feedCount > feedMax) {
            var last = feedContainer.lastElementChild;
            if (last) { feedContainer.removeChild(last); feedCount--; }
            else break;
        }
    }

    function feedTx(valueSat, feeRate, txid) {
        var btc = valueSat / 1e8;
        var valStr = btc >= 1 ? btc.toFixed(2) : btc >= 0.01 ? btc.toFixed(4) : btc.toFixed(6);
        var shortId = txid ? txid.substring(0, 8) + '‚Ä¶' : '';
        var feeStr = Math.round(feeRate) + ' sat2/vB';
        addFeedItem('tx',
            '<span class="feed-val">' + valStr + ' BC2</span> entered the pool' +
            ' ¬∑ <span class="feed-fee">' + feeStr + '</span>' +
            (shortId ? ' <span style="color:var(--t3);font-size:0.55rem;">' + shortId + '</span>' : '')
        );
    }

    function feedBlock(height, txCount, scooped) {
        addFeedItem('block',
            '<span class="feed-block">Block #' + (height ? height.toLocaleString() : '?') + '</span> mined ‚Äî ' +
            (scooped || txCount || '?') + ' txns scooped'
        );
    }

    function feedInfo(msg) {
        addFeedItem('info', msg);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  EVENT TRIGGER PANEL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window._trigEvt = function(name) {
        var triggerMap = {
            addFish: function() {
                var f = createFish({
                    feeRate: 1 + Math.random() * 80,
                    value: Math.floor(5000 + Math.random() * 5e8),
                });
                fishes.push(f);
                updateFishCount();
                feedInfo('<span style="color:var(--biolum);">üêü Manual fish spawned</span>');
            },
            bubbleVent: function() { ventActive = false; activeVent = null; triggerBubbleVent(); },
            schooling: function() {
                if (schoolEvent) {
                    schoolEvent.fish.forEach(function(f) { f._schooling = false; });
                    if (schoolEvent.centerFish) schoolEvent.centerFish._schooling = false;
                }
                schoolEvent = null; triggerSchooling();
            },
            biolumPulse: function() { biolumPulse = null; triggerBiolumPulse(); },
            jellyfish: function() { jellyfishEvent = null; triggerJellyfish(); },
            predatorChase: function() {
                if (predator && predator.prey && predator.prey.alive) {
                    predator.prey._scared = false;
                    predator.prey.tailSpeed = predator.prey.baseTailSpeed || 4;
                }
                predator = null; spawnPredatorChase();
                // Spawn at screen edge, visible immediately
                if (predator) { predator.x = predator.dir > 0 ? -10 : W + 10; predator.alpha = 0.6; }
            },
            currentSweep: function() { currentSweep = null; triggerCurrentSweep(); },
            baitball: function() { baitball = null; triggerBaitball(); },
            hermitCrab: function() { hermitCrab = null; triggerHermitCrab(); },
            treasureDrop: function() { treasure = null; triggerTreasureDrop(); },
            tideChange: function() { tideChange = null; triggerTideChange(); },
            planktonBloom: function() { planktonBloom = null; triggerPlanktonBloom(); },
            electricEel: function() {
                if (electricEel) { electricEel.stunned.forEach(function(sf) { sf._stunned = false; }); }
                electricEel = null; triggerElectricEel();
                if (electricEel) { electricEel.x = electricEel.dir > 0 ? -5 : W + 5; electricEel.alpha = 0.7; }
            },
            anglerfish: function() { anglerfish = null; spawnAnglerfish();
                if (anglerfish) { anglerfish.x = anglerfish.dir > 0 ? 10 : W - 10; anglerfish.alpha = 0.5; }
            },
            seaTurtle: function() { seaTurtle = null; triggerSeaTurtle();
                if (seaTurtle) { seaTurtle.x = seaTurtle.dir > 0 ? -5 : W + 5; seaTurtle.alpha = 0.5; }
            },
            seaquake: function() { seaquake = null; triggerSeaquake(); },
            mantaRay: function() { mantaRay = null; triggerMantaRay();
                if (mantaRay) { mantaRay.x = mantaRay.dir > 0 ? -20 : W + 20; mantaRay.alpha = 0.4; }
            },
            aurora: function() { aurora = null; triggerAurora(); },
            lightningStrike: function() { lightning = null; triggerLightning(); },
            krakenTentacle: function() { kraken = null; triggerKraken();
                if (kraken) { kraken.alpha = 0.5; }
            },
            bottleMessage: function() { bottleMsg = null; triggerBottleMessage();
                if (bottleMsg) { bottleMsg.alpha = 0.5; }
            },
            satoshiGhost: function() { satoshiGhost = null; triggerSatoshiGhost();
                if (satoshiGhost) { satoshiGhost.x = -30; satoshiGhost.alpha = 0.2; }
            },
            whale: function() { spawnWhale(999999, 2500); },
        };
        if (triggerMap[name]) triggerMap[name]();
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  TOOLTIP / HOVER
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var tooltip = document.getElementById('tooltip');
    var hoveredFish = null;

    canvas.addEventListener('mousemove', function(e) {
        var rect = canvas.getBoundingClientRect();
        var mx = e.clientX - rect.left;
        var my = e.clientY - rect.top;

        // Find closest fish
        var closest = null;
        var closestDist = 999;
        for (var i = 0; i < fishes.length; i++) {
            var f = fishes[i];
            if (f.scooped) continue;
            var dx = mx - f.x;
            var dy = my - f.y;
            var dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < f.size * 1.5 && dist < closestDist) {
                closest = f;
                closestDist = dist;
            }
        }

        if (closest) {
            hoveredFish = closest;
            var btcVal = (closest.value / 1e8).toFixed(closest.value > 1e8 ? 2 : 4);
            tooltip.innerHTML =
                '<div class="tt-value">' + btcVal + ' BC2</div>' +
                '<div>Fee: <span class="tt-fee">' + closest.feeRate + ' sat2/vB</span></div>' +
                '<div>Size: ' + closest.size.toFixed(0) + 'px ¬∑ Speed: ' + Math.abs(closest.vx).toFixed(1) + '</div>' +
                (closest.isUser ? '<div style="color:var(--biolum);margin-top:2px;">‚ú¶ Your transaction</div>' : '') +
                (closest.isRbf ? '<div style="color:#e64632;margin-top:2px;">‚ö° RBF Replacement ‚Äî hunting ' + (closest.rbfOldTxid || '').substring(0, 8) + '‚Ä¶</div>' : '') +
                (closest.rbfHunted ? '<div style="color:#e64632;margin-top:2px;">‚ö† Being replaced (RBF)</div>' : '') +
                '<div class="tt-hash">' + closest.txid + '</div>';
            tooltip.classList.add('visible');
            tooltip.style.left = Math.min(e.clientX + 15, window.innerWidth - 280) + 'px';
            tooltip.style.top = (e.clientY - 10) + 'px';
        } else {
            hoveredFish = null;
            tooltip.classList.remove('visible');
        }
    });

    canvas.addEventListener('mouseleave', function() {
        hoveredFish = null;
        tooltip.classList.remove('visible');
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  MARINE SNOW PARTICLES
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var snowContainer = document.getElementById('marineSnow');

    function spawnSnow() {
        var p = document.createElement('div');
        p.className = 'snow-particle';
        var size = 1 + Math.random() * 2;
        p.style.width = size + 'px';
        p.style.height = size + 'px';
        p.style.left = Math.random() * 100 + '%';
        p.style.background = Math.random() > 0.5 ? 'rgba(56,189,248,0.3)' : 'rgba(255,255,255,0.2)';
        p.style.animationDuration = (15 + Math.random() * 25) + 's';
        p.style.animationDelay = (Math.random() * 10) + 's';
        p.style.setProperty('--drift', (Math.random() * 40 - 20) + 'px');
        snowContainer.appendChild(p);
        p.addEventListener('animationend', function() { p.remove(); });
    }
    for (var i = 0; i < 20; i++) setTimeout(spawnSnow, i * 300);
    setInterval(spawnSnow, 2000);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  BC2 API INTEGRATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var wsRef = null;
    var lastKnownHeight = 0;

    function fmtS(b) {
        if (b >= 1048576) return (b / 1048576).toFixed(1) + ' MB';
        if (b >= 1024) return (b / 1024).toFixed(0) + ' KB';
        return b + ' B';
    }

    async function apiFetch(path, timeout) {
        timeout = timeout || 8000;
        var order = activeHost ? [activeHost].concat(HOSTS.filter(function(h) { return h !== activeHost; })) : HOSTS;
        for (var i = 0; i < order.length; i++) {
            var urls = [order[i] + '/api' + path, order[i] + '/api/v1' + path];
            for (var j = 0; j < urls.length; j++) {
                try {
                    var controller = new AbortController();
                    var timer = setTimeout(function() { controller.abort(); }, timeout);
                    var r = await fetch(urls[j], { signal: controller.signal });
                    clearTimeout(timer);
                    if (r.ok) {
                        activeHost = order[i];
                        return await r.json();
                    }
                } catch (e) { /* next */ }
            }
        }
        return null;
    }

    // Populate fish from mempool ‚Äî only real transaction data, no backfill
    async function fetchMempoolRecent() {
        // Don't re-fetch during whale passage or cleanup
        if (whale || whaleCleanupPending) return false;

        var totalAdded = 0;
        var totalRemoved = 0;
        var existing = {};
        for (var f = 0; f < fishes.length; f++) {
            if (fishes[f].txid) existing[fishes[f].txid] = true;
        }

        // 1) Try full mempool txid list first ‚Äî this is the authoritative source
        var gotTxids = false;
        var authoritativeSet = null;
        try {
            var txids = await apiFetch('/mempool/txids', 8000);
            if (txids && Array.isArray(txids)) {
                gotTxids = true;
                authoritativeSet = {};
                for (var t = 0; t < txids.length; t++) authoritativeSet[txids[t]] = true;

                // Remove any fish NOT in the current mempool (confirmed/dropped)
                for (var i = fishes.length - 1; i >= 0; i--) {
                    var fish = fishes[i];
                    if (fish.scooped || fish.rbfEaten || !fish.alive) continue;
                    if (fish.txid && !authoritativeSet[fish.txid]) {
                        if (txidMap[fish.txid]) delete txidMap[fish.txid];
                        fishes.splice(i, 1);
                        totalRemoved++;
                    }
                }

                // Rebuild existing map after removals
                existing = {};
                for (var f2 = 0; f2 < fishes.length; f2++) {
                    if (fishes[f2].txid) existing[fishes[f2].txid] = true;
                }

                // Add new txids we don't have
                for (var j = 0; j < txids.length; j++) {
                    if (existing[txids[j]]) continue;
                    fishes.push(createFish({
                        txid: txids[j],
                        feeRate: 1 + Math.random() * 8,
                        value: Math.round(Math.random() * 5e8),
                    }));
                    existing[txids[j]] = true;
                    totalAdded++;
                }
                console.log('[Aquarium] /mempool/txids: ' + txids.length + ' in mempool, +' + totalAdded + ' added, -' + totalRemoved + ' removed');
            }
        } catch (e) { console.warn('[Aquarium] mempool/txids error:', e); }

        // 2) Recent transactions ‚Äî richer data (fee/value), API returns max ~10
        //    If we got txids, this just enriches existing fish data
        //    If we didn't, this is our only source
        try {
            var recent = await apiFetch('/mempool/recent', 6000);
            if (recent && Array.isArray(recent)) {
                for (var r = 0; r < recent.length; r++) {
                    var tx = recent[r];
                    var id = tx.txid || ('tx_' + r);
                    if (existing[id]) continue;
                    // If we have authoritative set and this tx isn't in it, skip
                    if (authoritativeSet && !authoritativeSet[id]) continue;
                    fishes.push(createFish({
                        txid: id,
                        feeRate: tx.fee ? Math.max(1, Math.round(tx.fee / (tx.vsize || tx.weight / 4 || 200))) : (1 + Math.random() * 5),
                        value: tx.value || Math.round(Math.random() * 5e8),
                    }));
                    existing[id] = true;
                    totalAdded++;
                }
            }
        } catch (e) { console.warn('[Aquarium] mempool/recent error:', e); }

        if (totalAdded > 0 || totalRemoved > 0) {
            console.log('[Aquarium] Net result: ' + totalAdded + ' added, ' + totalRemoved + ' removed, ' + fishes.filter(function(x) { return !x.scooped && x.alive; }).length + ' active fish');
            updateFishCount();
            if (totalAdded > 0) {
                feedInfo('Loaded <span class="feed-val">' + totalAdded + '</span> pending transactions from mempool');
            }
            return true;
        }
        return false;
    }

    async function fetchMempoolStats() {
        // Mempool stats
        var mp = await apiFetch('/mempool');
        if (mp) {
            var txCount = mp.count || mp.size || 0;
            var mSize = mp.vsize || mp.bytes || mp.usage || 0;
            var el1 = document.getElementById('statTxCount');
            var el2 = document.getElementById('statMempoolSize');
            if (el1) el1.textContent = txCount.toLocaleString();
            if (el2) el2.textContent = fmtS(mSize);
        }

        // Fees
        var fees = await apiFetch('/v1/fees/recommended');
        if (!fees) fees = await apiFetch('/fees/recommended');
        if (fees) {
            var el3 = document.getElementById('statLowFee');
            var el4 = document.getElementById('statMedFee');
            if (el3) el3.textContent = (fees.minimumFee || fees.economyFee || fees.hourFee || '‚Äî') + ' sat2/vB';
            if (el4) el4.textContent = (fees.halfHourFee || fees.fastestFee || '‚Äî') + ' sat2/vB';
        }

        // Tip height
        var blocks = await apiFetch('/blocks', 5000);
        if (blocks && blocks.length) {
            lastKnownHeight = blocks[0].height;
            var el5 = document.getElementById('nextBlock');
            if (el5) el5.textContent = '#' + (blocks[0].height + 1).toLocaleString();
            var el6 = document.getElementById('lastBlockTime');
            var el7 = document.getElementById('lastBlockStat');
            if (el6 && el7) {
                var ago = Math.floor(Date.now() / 1000) - blocks[0].timestamp;
                el6.textContent = ago < 60 ? ago + 's ago' : Math.floor(ago / 60) + 'm ago';
                el7.style.display = '';
            }
        }
    }

    // WebSocket for live tx and block events
    function connectWS() {
        if (!activeHost) return;
        var wsUrl = activeHost.replace('https://', 'wss://') + '/api/v1/ws';
        try {
            var ws = new WebSocket(wsUrl);
            var timeout = setTimeout(function() { ws.close(); }, 8000);

            ws.onopen = function() {
                clearTimeout(timeout);
                wsRef = ws;
                setStatus('live', 'Live ¬∑ ' + activeHost.replace('https://', ''));
                ws.send(JSON.stringify({ action: 'init' }));
                ws.send(JSON.stringify({ action: 'want', data: ['blocks', 'mempool-blocks', 'stats', 'rbf'] }));
                feedInfo('WebSocket connected to <span style="color:var(--biolum)">' + activeHost.replace('https://', '') + '</span>');
            };

            ws.onmessage = function(ev) {
                try {
                    var msg = JSON.parse(ev.data);

                    // New transaction
                    if (msg.tx) {
                        // Don't add fish during whale (block) passage or cleanup
                        if (whale || whaleCleanupPending) { /* skip */ } else {
                        var tx = msg.tx;
                        var txFee = tx.feeRate || tx.fee || (1 + Math.random() * 5);
                        var txVal = tx.value || Math.round(Math.random() * 5e8);
                        var txId = tx.txid || 'ws_tx';
                        fishes.push(createFish({
                            txid: txId,
                            feeRate: txFee,
                            value: txVal,
                        }));
                        updateFishCount();
                        feedTx(txVal, txFee, txId);
                        }
                    }

                    // RBF replacement ‚Äî various API formats
                    if (msg.rbfTransaction) {
                        var rbf = msg.rbfTransaction;
                        var newId = rbf.txid;
                        var replacedIds = rbf.replacedBy ? [rbf.replacedBy.txid] :
                                          rbf.replaces ? (Array.isArray(rbf.replaces) ? rbf.replaces : [rbf.replaces]) :
                                          rbf.mpiCount ? [] : [];
                        var newFeeR = rbf.feeRate || rbf.fee || 5;
                        var newVal = rbf.value || 0;
                        for (var ri = 0; ri < replacedIds.length; ri++) {
                            spawnRbfPredator(newId, replacedIds[ri], newFeeR, newVal);
                        }
                    }
                    // Alternative format: array of RBF events
                    if (msg['rbf-transactions'] && Array.isArray(msg['rbf-transactions'])) {
                        var rbfArr = msg['rbf-transactions'];
                        for (var rj = 0; rj < rbfArr.length; rj++) {
                            var re = rbfArr[rj];
                            if (re.new && re.old) {
                                spawnRbfPredator(
                                    re.new.txid || re.new,
                                    re.old.txid || re.old,
                                    re.new.feeRate || re.new.fee || 5,
                                    re.new.value || 0
                                );
                            }
                        }
                    }

                    // New block ‚Äî trigger whale!
                    if (msg.block) {
                        var b = msg.block;
                        if (b.height && b.height > lastKnownHeight) {
                            lastKnownHeight = b.height;
                            var el = document.getElementById('nextBlock');
                            if (el) el.textContent = '#' + (b.height + 1).toLocaleString();
                            var scoopCount = b.tx_count || fishes.length;
                            spawnWhale(b.height, scoopCount);
                            feedBlock(b.height, scoopCount);
                        }
                    }

                    // Mempool stats
                    if (msg.mempoolInfo) {
                        var mi = msg.mempoolInfo;
                        var e1 = document.getElementById('statTxCount');
                        var e2 = document.getElementById('statMempoolSize');
                        if (e1 && mi.size) e1.textContent = mi.size.toLocaleString();
                        if (e2 && mi.bytes) e2.textContent = fmtS(mi.bytes);
                    }
                } catch (e) { }
            };

            ws.onclose = function() {
                wsRef = null;
                setStatus('connecting', 'Reconnecting‚Ä¶');
                setTimeout(connectWS, 5000);
            };

            ws.onerror = function() { ws.close(); };
        } catch (e) {
            setTimeout(connectWS, 5000);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  INITIALIZATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    async function init() {
        setStatus('connecting', 'Connecting to BC2‚Ä¶');
        feedInfo('Connecting to BC2 network‚Ä¶');

        // Try API
        var gotData = await fetchMempoolRecent();
        if (gotData) {
            setStatus('live', 'Connected ¬∑ ' + activeHost.replace('https://', ''));
        } else {
            setStatus('connecting', 'Waiting for data‚Ä¶');
            feedInfo('Mempool API unavailable ‚Äî waiting for WebSocket');
        }

        await fetchMempoolStats();

        // Try WebSocket for live updates
        connectWS();

        // Periodic stats refresh
        setInterval(fetchMempoolStats, 60000);

        // Periodic mempool sync ‚Äî reconciles fish against actual mempool state
        setInterval(async function() {
            if (!whale && !whaleCleanupPending && (Date.now() - lastBlockMinedAt > POST_BLOCK_COOLDOWN)) {
                await fetchMempoolRecent();
            }
        }, 15000);

        // Periodic RBF check via REST API fallback
        setInterval(async function() {
            try {
                var rbfs = await apiFetch('/v1/replacements', 5000);
                if (!rbfs) rbfs = await apiFetch('/replacements', 5000);
                if (rbfs && Array.isArray(rbfs)) {
                    for (var i = 0; i < rbfs.length; i++) {
                        var r = rbfs[i];
                        var newTx = r.tx || r.replacement || r;
                        var oldTxid = r.replaces || (r.replacedTx && r.replacedTx.txid) || null;
                        if (newTx.txid && oldTxid && txidMap[oldTxid] && !txidMap[oldTxid].rbfHunted) {
                            spawnRbfPredator(newTx.txid, oldTxid, newTx.feeRate || newTx.fee, newTx.value);
                        }
                    }
                }
            } catch (e) { /* RBF endpoint may not exist */ }
        }, 20000);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    //  FULLSCREEN TOGGLE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    var fsBtn = document.getElementById('fsBtn');
    var fsIconExpand = document.getElementById('fsIconExpand');
    var fsIconShrink = document.getElementById('fsIconShrink');
    var fsHint = document.getElementById('fsHint');

    function updateFsIcon() {
        var isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
        fsIconExpand.style.display = isFs ? 'none' : '';
        fsIconShrink.style.display = isFs ? '' : 'none';
    }

    fsBtn.addEventListener('click', function() {
        var fsEl = document.fullscreenElement || document.webkitFullscreenElement;
        if (!fsEl) {
            var el = document.documentElement;
            (el.requestFullscreen || el.webkitRequestFullscreen).call(el).then(function() {
                fsHint.style.display = 'flex';
                setTimeout(function() { resize(); }, 100);
            }).catch(function() {});
        } else {
            (document.exitFullscreen || document.webkitExitFullscreen).call(document);
        }
    });

    document.addEventListener('fullscreenchange', function() {
        updateFsIcon();
        setTimeout(function() {
            resize();
            generateGodRays();
            generateOrbs();
            generateKelp();
            generateSeabed();
        }, 50);
    });
    document.addEventListener('webkitfullscreenchange', function() {
        updateFsIcon();
        setTimeout(function() {
            resize();
            generateGodRays();
            generateOrbs();
            generateKelp();
            generateSeabed();
        }, 50);
    });

    init();

})();
</script>
</body>
</html>
